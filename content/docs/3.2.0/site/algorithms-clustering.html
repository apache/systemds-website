<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->
<!--

-->

<head>
    <title>Algorithms Reference Clustering - SystemDS 3.2.0</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="./../css/bootstrap.min.css">
    <link rel="stylesheet" href="./../css/main.css">
    <link rel="stylesheet" href="./../css/pygments-default.css">
    <link rel="shortcut icon" href="./../img/favicon.png">
    <script src="./../js/vendor/jquery-1.12.0.min.js"></script>
    <script src="./../js/vendor/bootstrap.min.js"></script>
    <script src="./../js/vendor/anchor.min.js"></script>
    <script src="./../js/main.js"></script>
</head>

<body>
    <!--

-->
<header class="navbar navbar-default navbar-fixed-top" id="topbar">
    <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand brand projectlogo">
                <a href="https://systemds.apache.org/"><img class="logo" src="./../img/systemds-logo.png" alt="Apache SystemDS" title="Apache SystemDS" /></a>
            </div>
            <div class="navbar-brand brand projecttitle">
                <a href="https://systemds.apache.org/">Apache SystemDS<sup id="trademark">â„¢</sup></a><br />
                <span class="version">3.2.0</span>
            </div>
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <nav class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Overview<b class="caret"></b></a>
                    <ul class="dropdown-menu" role="menu">
                        <li><b>Home:</b></li>
                        <li><a href="./../">Docs Home</a></li>
                        <li class="divider"></li>
                        <li><b>Running SystemDS:</b></li>
                        <li><a href="./../site/run">Standalone Guide</a></li>
                        <li><a href="./../site/gpu">GPU Guide</a></li>
                        <li><a href="./../site/native-backend">Native Backend (BLAS)</a></li>
                        <li><a href="./../site/docker">Run with Docker</a></li>
                        <li class="divider"></li>
                        <li><b>Language Guides:</b></li>
                        <li><a href="./../site/dml-language-reference.html">DML Language Reference</a></li>
                        <li><a href="./../site/builtins-reference.html">Built-in Functions Reference</a></li>
                        <li><a href="./../site/dml-vs-r-guide.html">DML vs R guide</a></li>
                        <li class="divider"></li>
                        <li><b>Algorithms:</b></li>
                        <li><a href="./../site/algorithms-reference.html">ML Algorithms Reference</a></li>
                        <li class="divider"></li>
                        <li><b>Other:</b></li>
                        <li><a href="https://github.com/apache/systemds/blob/main/CONTRIBUTING.md">Contributing to SystemDS ðŸ¡•</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/apache/systemds">GitHub ðŸ¡•</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">API<b class="caret"></b></a>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="./../api/java/">Java</a></li>
                        <li><a href="./../api/python/">Python</a></li>
                    </ul>
                </li>
                <li><a href="https://issues.apache.org/jira/secure/Dashboard.jspa?selectPageId=12335852">Issues</a></li>
            </ul>
        </nav>
    </div>
</header>

    <div class="container" id="content">
        <h1 class="title">Algorithms Reference Clustering</h1>
        <!--

-->

<h2 id="k-means-clustering">K-Means Clustering</h2>

<h3 id="k-means-description">K-Means Description</h3>

<p>Given a collection of $n$ records with a pairwise similarity measure,
the goal of clustering is to assign a category label to each record so
that similar records tend to get the same label. In contrast to
multinomial logistic regression, clustering is an <em>unsupervised</em>
learning problem with neither category assignments nor label
interpretations given in advance. In $k$-means clustering, the records
$x_1, x_2, \ldots, x_n$ are numerical feature vectors of $\dim x_i = m$
with the squared Euclidean distance $|x_i - x_{i&#8217;}|_2^2$ as the
similarity measure. We want to partition $\{x_1, \ldots, x_n\}$ into $k$
clusters $\{S_1, \ldots, S_k\}$ so that the aggregated squared distance
from records to their cluster means is minimized:</p>

\[\begin{equation}
\textrm{WCSS}\,\,=\,\, \sum_{i=1}^n \,\big\|x_i - mean(S_j: x_i\in S_j)\big\|_2^2 \,\,\to\,\,\min
\end{equation}\]

<p>The aggregated distance measure in (1) is
called the <em>within-cluster sum of squares</em> (WCSS). It can be viewed as a
measure of residual variance that remains in the data after the
clustering assignment, conceptually similar to the residual sum of
squares (RSS) in linear regression. However, unlike for the RSS, the
minimization of (1) is an NP-hard
problem <a href="algorithms-bibliography.html">[AloiseDHP2009]</a>.</p>

<p>Rather than searching for the global optimum in (1), a
heuristic algorithm called Lloydâ€™s algorithm is typically used. This
iterative algorithm maintains and updates a set of $k$ <em>centroids</em>
$\{c_1, \ldots, c_k\}$, one centroid per cluster. It defines each
cluster $S_j$ as the set of all records closer to $c_j$ than to any
other centroid. Each iteration of the algorithm reduces the WCSS in two
steps:</p>

<ol>
  <li>Assign each record to the closest centroid, making
$mean(S_j)\neq c_j$</li>
  <li>Reset each centroid to its clusterâ€™s mean:
$c_j := mean(S_j)$</li>
</ol>

<p>After Step 1, the centroids are generally
different from the cluster means, so we can compute another
&#8220;within-cluster sum of squares&#8221; based on the centroids:</p>

\[\textrm{WCSS_C}\,\,=\,\, \sum_{i=1}^n \,\big\|x_i - \mathop{\textrm{centroid}}(S_j: x_i\in S_j)\big\|_2^2
\label{eqn:WCSS:C}\]

<p>This WCSS_C after Step 1
is less than the means-based WCSS before Step 1
(or equal if convergence achieved), and in Step 2
the WCSS cannot exceed the WCSS_C for <em>the same</em> clustering; hence the
WCSS reduction.</p>

<p>Exact convergence is reached when each record becomes closer to its
clusterâ€™s mean than to any other clusterâ€™s mean, so there are no more
re-assignments and the centroids coincide with the means. In practice,
iterations may be stopped when the reduction in WCSS (or in WCSS_C)
falls below a minimum threshold, or upon reaching the maximum number of
iterations. The initialization of the centroids is also an important
part of the algorithm. The smallest WCSS obtained by the algorithm is
not the global minimum and varies depending on the initial centroids. We
implement multiple parallel runs with different initial centroids and
report the best result.</p>

<p><strong>Scoring.</strong> Our scoring script evaluates the clustering output by comparing it with
a known category assignment. Since cluster labels have no prior
correspondence to the categories, we cannot count &#8220;correct&#8221; and &#8220;wrong&#8221;
cluster assignments. Instead, we quantify them in two ways:</p>

<ol>
  <li>Count how many same-category and different-category pairs of records end
up in the same cluster or in different clusters;</li>
  <li>For each category, count the prevalence of its most common cluster; for
each cluster, count the prevalence of its most common category.</li>
</ol>

<p>The number of categories and the number of clusters ($k$) do not have to
be equal. A same-category pair of records clustered into the same
cluster is viewed as a &#8220;true positive,&#8221; a different-category pair
clustered together is a &#8220;false positive,&#8221; a same-category pair clustered
apart is a &#8220;false negative&#8221; etc.</p>

<hr />

<h4 id="table-6">Table 6</h4>

<p>The O-file for Kmeans-predict provides the
output statistics in CSV format, one per line, in the following
format: (NAME, [CID], VALUE). Note: the 1st group statistics are
given if X input is available; the 2nd group statistics
are given if X and C inputs are available;
the 3rd and 4th group statistics are given if spY input
is available; only the 4th group statistics contain a nonempty CID
value; when present, CID contains either the specified category label
or the predicted cluster label.</p>

<table>
  <thead>
    <tr>
      <th>Inputs Available</th>
      <th>Name</th>
      <th>CID</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center" rowspan="5">X</td>
      <td>TSS</td>
      <td>&#160;</td>
      <td>Total Sum of Squares (from the total mean)</td>
    </tr>
    <tr>
      <td>WCSS_M</td>
      <td>&#160;</td>
      <td>Within-Cluster Sum of Squares (means as centers)</td>
    </tr>
    <tr>
      <td>WCSS_M_PC</td>
      <td>&#160;</td>
      <td>Within-Cluster Sum of Squares (means), in % of TSS</td>
    </tr>
    <tr>
      <td>BCSS_M</td>
      <td>&#160;</td>
      <td>Between-Cluster Sum of Squares (means as centers)</td>
    </tr>
    <tr>
      <td>BCSS_M_PC</td>
      <td>&#160;</td>
      <td>Between-Cluster Sum of Squares (means), in % of TSS</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="4">X and C</td>
      <td>WCSS_C</td>
      <td>&#160;</td>
      <td>Within-Cluster Sum of Squares (centroids as centers)</td>
    </tr>
    <tr>
      <td>WCSS_C_PC</td>
      <td>&#160;</td>
      <td>Within-Cluster Sum of Squares (centroids), % of TSS</td>
    </tr>
    <tr>
      <td>BCSS_C</td>
      <td>&#160;</td>
      <td>Between-Cluster Sum of Squares (centroids as centers)</td>
    </tr>
    <tr>
      <td>BCSS_C_PC</td>
      <td>&#160;</td>
      <td>Between-Cluster Sum of Squares (centroids), % of TSS</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="8">spY</td>
      <td>TRUE_SAME_CT</td>
      <td>&#160;</td>
      <td>Same-category pairs predicted as Same-cluster, count</td>
    </tr>
    <tr>
      <td>TRUE_SAME_PC</td>
      <td>&#160;</td>
      <td>Same-category pairs predicted as Same-cluster, %</td>
    </tr>
    <tr>
      <td>TRUE_DIFF_CT</td>
      <td>&#160;</td>
      <td>Diff-category pairs predicted as Diff-cluster, count</td>
    </tr>
    <tr>
      <td>TRUE_DIFF_PC</td>
      <td>&#160;</td>
      <td>Diff-category pairs predicted as Diff-cluster, %</td>
    </tr>
    <tr>
      <td>FALSE_SAME_CT</td>
      <td>&#160;</td>
      <td>Diff-category pairs predicted as Same-cluster, count</td>
    </tr>
    <tr>
      <td>FALSE_SAME_PC</td>
      <td>&#160;</td>
      <td>Diff-category pairs predicted as Same-cluster, %</td>
    </tr>
    <tr>
      <td>FALSE_DIFF_CT</td>
      <td>&#160;</td>
      <td>Same-category pairs predicted as Diff-cluster, count</td>
    </tr>
    <tr>
      <td>FALSE_DIFF_PC</td>
      <td>&#160;</td>
      <td>Same-category pairs predicted as Diff-cluster, %</td>
    </tr>
    <tr>
      <td style="text-align: center" rowspan="8">spY</td>
      <td>SPEC_TO_PRED</td>
      <td style="text-align: center">+</td>
      <td>For specified category, the best predicted cluster id</td>
    </tr>
    <tr>
      <td>SPEC_FULL_CT</td>
      <td style="text-align: center">+</td>
      <td>For specified category, its full count</td>
    </tr>
    <tr>
      <td>SPEC_MATCH_CT</td>
      <td style="text-align: center">+</td>
      <td>For specified category, best-cluster matching count</td>
    </tr>
    <tr>
      <td>SPEC_MATCH_PC</td>
      <td style="text-align: center">+</td>
      <td>For specified category, % of matching to full count</td>
    </tr>
    <tr>
      <td>PRED_TO_SPEC</td>
      <td style="text-align: center">+</td>
      <td>For predicted cluster, the best specified category id</td>
    </tr>
    <tr>
      <td>PRED_FULL_CT</td>
      <td style="text-align: center">+</td>
      <td>For predicted cluster, its full count</td>
    </tr>
    <tr>
      <td>PRED_MATCH_CT</td>
      <td style="text-align: center">+</td>
      <td>For predicted cluster, best-category matching count</td>
    </tr>
    <tr>
      <td>PRED_MATCH_PC</td>
      <td style="text-align: center">+</td>
      <td>For predicted cluster, % of matching to full count</td>
    </tr>
  </tbody>
</table>

<hr />

<h3 id="k-means-details">K-Means Details</h3>

<p>Our clustering script proceeds in 3 stages: centroid initialization,
parallel $k$-means iterations, and the best-available output generation.
Centroids are initialized at random from the input records (the rows
of $X$), biased towards being chosen far apart from each other. The
initialization method is based on the <code class="language-plaintext highlighter-rouge">k-means++</code> heuristic
from <a href="algorithms-bibliography.html">[ArthurVassilvitskii2007]</a>, with one important difference: to
reduce the number of passes through $X$, we take a small sample of $X$
and run the <code class="language-plaintext highlighter-rouge">k-means++</code> heuristic over this sample. Here is,
conceptually, our centroid initialization algorithm for one clustering
run:</p>

<ol>
  <li>Sample the rows of $X$ uniformly at random, picking each row with
probability $p = ks / n$ where
    <ul>
      <li>$k$ is the number of centroids</li>
      <li>$n$ is the number of records</li>
      <li>$s$ is the samp input parameter</li>
    </ul>

    <p>If $ks \geq n$, the entire $X$ is used in place of its sample.</p>
  </li>
  <li>Choose the first centroid uniformly at random from the sampled rows.</li>
  <li>Choose each subsequent centroid from the sampled rows, at random, with
probability proportional to the squared Euclidean distance between the
row and the nearest already-chosen centroid.</li>
</ol>

<p>The sampling of $X$ and the selection of centroids are performed
independently and in parallel for each run of the $k$-means algorithm.
When we sample the rows of $X$, rather than tossing a random coin for
each row, we compute the number of rows to skip until the next sampled
row as $\lceil \log(u) / \log(1 - p) \rceil$ where $u\in (0, 1)$ is
uniformly random. This time-saving trick works because</p>

\[Prob[k-1 &lt; \log_{1-p}(u) &lt; k] \,\,=\,\, p(1-p)^{k-1} \,\,=\,\,
Prob[\textrm{skip $k-1$ rows}]\]

<p>However, it requires us to estimate the maximum sample size, which we
set near $ks + 10\sqrt{ks}$ to make it generous enough.</p>

<p>Once we selected the initial centroid sets, we start the $k$-means
iterations independently in parallel for all clustering runs. The number
of clustering runs is given as the runs input parameter.
Each iteration of each clustering run performs the following steps:</p>

<ul>
  <li>Compute the centroid-dependent part of squared Euclidean distances from
all records (rows of $X$) to each of the $k$ centroids using matrix
product.</li>
  <li>Take the minimum of the above for each record.</li>
  <li>Update the current within-cluster sum of squares (WCSS) value, with
centroids substituted instead of the means for efficiency.</li>
  <li>
    <p>Check the convergence</p>

    <p>criterion:</p>

\[\textrm{WCSS}_{\mathrm{old}} - \textrm{WCSS}_{\mathrm{new}} &lt; {\varepsilon}\cdot\textrm{WCSS}_{\mathrm{new}}\]

    <p>as well as the number of iterations limit.</p>
  </li>
  <li>Find the closest centroid for each record, sharing equally any records with multiple closest centroids.</li>
  <li>Compute the number of records closest to each centroid, checking for
&#8220;runaway&#8221; centroids with no records left (in which case the run fails).</li>
  <li>Compute the new centroids by averaging the records in their clusters.</li>
</ul>

<p>When a termination condition is satisfied, we store the centroids and
the WCSS value and exit this run. A run has to satisfy the WCSS
convergence criterion to be considered successful. Upon the termination
of all runs, we select the smallest WCSS value among the successful
runs, and write out this runâ€™s centroids. If requested, we also compute
the cluster assignment of all records in $X$, using integers from 1
to $k$ as the cluster labels. The scoring script can then be used to
compare the cluster assignment with an externally specified category
assignment.</p>

<h3 id="returns">Returns</h3>

<p>We output the $k$ centroids for the best available clustering,
i. e. whose WCSS is the smallest of all successful runs. The centroids
are written as the rows of the $k\,{\times}\,m$-matrix into the output
file whose path/name was provided as the <code class="language-plaintext highlighter-rouge">C</code> input
argument. If the input parameter <code class="language-plaintext highlighter-rouge">isY</code> was set
to <code class="language-plaintext highlighter-rouge">1</code>, we also output the one-column matrix with the cluster
assignment for all the records. This assignment is written into the file
whose path/name was provided as the <code class="language-plaintext highlighter-rouge">Y</code> input argument. The
best WCSS value, as well as some information about the performance of
the other runs, is printed during the script execution. The scoring
script <code class="language-plaintext highlighter-rouge">Kmeans-predict.dml</code> prints all its results in a
self-explanatory manner, as defined in
<a href="#table-6"><strong>Table 6</strong></a>.</p>

    </div>
    <!--

-->


<!-- MathJax Section -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } });
</script>
<script>
    // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
    // We could use "//cdn.mathjax...", but that won't support "file://".
    (function(d, script) {
        script = d.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.onload = function() {
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [
                        ["$", "$"],
                        ["\\\\(", "\\\\)"]
                    ],
                    displayMath: [
                        ["$$", "$$"],
                        ["\\[", "\\]"]
                    ],
                    processEscapes: true,
                    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            });
        };
        script.src = ('https:' == document.location.protocol ? 'https://' : 'http://') +
            'cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        d.getElementsByTagName('head')[0].appendChild(script);
    }(document));
</script>

</body>

</html>