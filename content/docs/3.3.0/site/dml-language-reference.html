<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->
<!--

-->

<head>
    <title>DML Language Reference - SystemDS 3.3.0</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="./../css/bootstrap.min.css">
    <link rel="stylesheet" href="./../css/main.css">
    <link rel="stylesheet" href="./../css/pygments-default.css">
    <link rel="shortcut icon" href="./../img/favicon.png">
    <script src="./../js/vendor/jquery-1.12.0.min.js"></script>
    <script src="./../js/vendor/bootstrap.min.js"></script>
    <script src="./../js/vendor/anchor.min.js"></script>
    <script src="./../js/main.js"></script>
</head>

<body>
    <!--

-->
<header class="navbar navbar-default navbar-fixed-top" id="topbar">
    <div class="container">
        <div class="navbar-header">
            <div class="navbar-brand brand projectlogo">
                <a href="https://systemds.apache.org/"><img class="logo" src="./../img/systemds-logo.png" alt="Apache SystemDS" title="Apache SystemDS" /></a>
            </div>
            <div class="navbar-brand brand projecttitle">
                <a href="https://systemds.apache.org/">Apache SystemDS<sup id="trademark">™</sup></a><br />
                <span class="version">3.3.0</span>
            </div>
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
        <nav class="navbar-collapse collapse">
            <ul class="nav navbar-nav navbar-right">
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Overview<b class="caret"></b></a>
                    <ul class="dropdown-menu" role="menu">
                        <li><b>Home:</b></li>
                        <li><a href="./../">Docs Home</a></li>
                        <li class="divider"></li>
                        <li><b>Running SystemDS:</b></li>
                        <li><a href="./../site/run">Standalone Guide</a></li>
                        <li><a href="./../site/gpu">GPU Guide</a></li>
                        <li><a href="./../site/native-backend">Native Backend (BLAS)</a></li>
                        <li><a href="./../site/docker">Run with Docker</a></li>
                        <li class="divider"></li>
                        <li><b>Language Guides:</b></li>
                        <li><a href="./../site/dml-language-reference.html">DML Language Reference</a></li>
                        <li><a href="./../site/builtins-reference.html">Built-in Functions Reference</a></li>
                        <li><a href="./../site/dml-vs-r-guide.html">DML vs R guide</a></li>
                        <li class="divider"></li>
                        <li><b>Algorithms:</b></li>
                        <li><a href="./../site/algorithms-reference.html">ML Algorithms Reference</a></li>
                        <li class="divider"></li>
                        <li><b>Other:</b></li>
                        <li><a href="https://github.com/apache/systemds/blob/main/CONTRIBUTING.md">Contributing to SystemDS 🡕</a></li>
                    </ul>
                </li>
                <li><a href="https://github.com/apache/systemds">GitHub 🡕</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">API<b class="caret"></b></a>
                    <ul class="dropdown-menu" role="menu">
                        <li><a href="./../api/java/">Java</a></li>
                        <li><a href="./../api/python/">Python</a></li>
                    </ul>
                </li>
                <li><a href="https://issues.apache.org/jira/secure/Dashboard.jspa?selectPageId=12335852">Issues</a></li>
            </ul>
        </nav>
    </div>
</header>

    <div class="container" id="content">
        <h1 class="title">DML Language Reference</h1>
        <!--

-->

<h3 id="table-of-contents">Table of Contents</h3>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#variables">Variables</a>
    <ul>
      <li><a href="#identifier-names">Identifier Names</a></li>
      <li><a href="#data-types">Data Types</a></li>
      <li><a href="#comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#expressions">Expressions</a>
    <ul>
      <li><a href="#operators">Operators</a></li>
      <li><a href="#matrix-vector-operations">Matrix-Vector Operations</a></li>
      <li><a href="#matrix-indexing">Matrix Indexing</a></li>
    </ul>
  </li>
  <li><a href="#statements">Statements</a>
    <ul>
      <li><a href="#assignment-statement">Assignment Statement</a></li>
      <li><a href="#control-statements">Control Statements</a>
        <ul>
          <li><a href="#while-statement">While Statement</a></li>
          <li><a href="#if-statement">If Statement</a></li>
          <li><a href="#for-statement">For Statement</a></li>
          <li><a href="#parfor-statement">ParFor Statement</a></li>
        </ul>
      </li>
      <li><a href="#user-defined-function-udf">User-Defined Function (UDF)</a></li>
    </ul>
  </li>
  <li><a href="#variable-scoping">Variable Scoping</a></li>
  <li><a href="#command-line-arguments">Command-Line Arguments</a></li>
  <li><a href="#built-in-functions">Built-in Functions</a>
    <ul>
      <li><a href="#matrix-construction-manipulation-and-aggregation-built-in-functions">Matrix Construction, Manipulation, and Aggregation Built-In Functions</a></li>
      <li><a href="#matrix-andor-scalar-comparison-built-in-functions">Matrix and/or Scalar Comparison Built-In Functions</a></li>
      <li><a href="#casting-built-in-functions">Casting Built-In Functions</a></li>
      <li><a href="#statistical-built-in-functions">Statistical Built-In Functions</a></li>
      <li><a href="#mathematical-and-trigonometric-built-in-functions">Mathematical and Trigonometric Built-In Functions</a></li>
      <li><a href="#linear-algebra-built-in-functions">Linear Algebra Built-In Functions</a></li>
      <li><a href="#readwrite-built-in-functions">Read/Write Built-In Functions</a></li>
      <li><a href="#data-pre-processing-built-in-functions">Data Pre-Processing Built-In Functions</a></li>
      <li><a href="#deep-learning-built-in-functions">Deep Learning Built-In Functions</a></li>
      <li><a href="#parameter-server-built-in-function">Parameter Server Built-In Function</a></li>
      <li><a href="#other-built-in-functions">Other Built-In Functions</a></li>
    </ul>
  </li>
  <li><a href="#frames">Frames</a>
    <ul>
      <li><a href="#creating-frames">Creating Frames</a></li>
      <li><a href="#appending-frames">Appending Frames</a></li>
      <li><a href="#indexing-frames">Indexing Frames</a></li>
      <li><a href="#casting-frames">Casting Frames</a></li>
      <li><a href="#transforming-frames">Transforming Frames</a></li>
      <li><a href="#processing-frames">Processing Frames</a></li>
    </ul>
  </li>
  <li><a href="#modules">Modules</a></li>
  <li><a href="#reserved-keywords">Reserved Keywords</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>SystemDS compiles scripts written in Declarative Machine Learning (or DML for short) into mixed driver and distributed jobs. DML’s syntax closely follows R, thereby minimizing the learning curve to use SystemDS. Before getting into detail, let’s start with a simple Hello World program in DML. Assuming that Spark is installed on your machine or cluster, place <code class="language-plaintext highlighter-rouge">SystemDS.jar</code> into your directory. Now, create a text file <code class="language-plaintext highlighter-rouge">hello.dml</code> containing following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Hello World");
</code></pre></div></div>

<p>To run this program on your machine, use following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spark-submit SystemDS.jar -f hello.dml
</code></pre></div></div>

<p>The option <code class="language-plaintext highlighter-rouge">-f</code> in the above command refers to the path to the DML script. A detailed list of the
available options can be found running <code class="language-plaintext highlighter-rouge">spark-submit SystemDS.jar -help</code>.</p>

<h2 id="variables">Variables</h2>

<h3 id="identifier-names">Identifier Names</h3>

<p>Identifiers are case-sensitive (e.g., <code class="language-plaintext highlighter-rouge">var1</code>, <code class="language-plaintext highlighter-rouge">Var1</code>, and <code class="language-plaintext highlighter-rouge">VAR1</code> are different identifier names), must start with either an upper-case or lower-case letter, and may contain any alphanumeric character including underscore after the first letter. The reserved keywords described later cannot be used as identifier names. Though it is allowed, but not recommended to use built-in functions as an identifier. The only exceptions to this rule are five built-in functions: &#8216;as.scalar&#8217;, &#8216;as.matrix&#8217;, &#8216;as.double&#8217;, &#8216;as.integer&#8217; and &#8216;as.logical&#8217;.</p>

<h4 id="examples">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A       # valid variable name
_A      # invalid variable name -- starts with underscore
1_A     # invalid variable name -- starts with number
A_1     # valid variable name
min = 10 # valid but deprecated
</code></pre></div></div>

<p>Before, proceeding ahead let’s run the Hello World program using variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>helloStr = "Hello World"
print(helloStr)
</code></pre></div></div>

<p>As seen in above example, there is no formal declaration of a variable. A variable is created when first assigned a value, and its type is inferred.</p>

<h3 id="data-types">Data Types</h3>

<p>Three data types (frame, matrix and scalar) and four value types (double, integer, string, and boolean) are supported. Matrices are 2-dimensional, and support the double value type (i.e., the cells in a matrix are of type double). The frame data type denotes the tabular data, potentially containing columns of value type numeric, string, and boolean.  Frame functions are described in <a href="#frames">Frames</a> and  <a href="#data-pre-processing-built-in-functions">Data Pre-Processing Built-In Functions</a>.  SystemDS supports type polymorphism for both data type (primarily, matrix and scalar types) and value type during evaluation. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Spoiler alert: matrix() is a built-in function to
# create matrix, which will be discussed later
A = matrix(0, rows=10, cols=10)
B = 10
C = B + sum(A)
print( "B:" + B + ", C:" + C + ", A[1,1]:" + as.scalar(A[1,1]))
</code></pre></div></div>

<p>In the above script, we create three variables: <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">C</code> of type <code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar integer</code> and <code class="language-plaintext highlighter-rouge">scalar double</code> respectively. Since <code class="language-plaintext highlighter-rouge">A</code> is a <code class="language-plaintext highlighter-rouge">matrix</code>, it has to be converted to scalar using a built-in function <code class="language-plaintext highlighter-rouge">as.scalar</code>. In the above script the operator <code class="language-plaintext highlighter-rouge">+</code> used inside <code class="language-plaintext highlighter-rouge">print()</code> function, performs string concatenation. Hence, the output of above script is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>B:10, C:10.0, A[1,1]:0.0
</code></pre></div></div>

<p>If instead of <code class="language-plaintext highlighter-rouge">as.scalar(A[1,1])</code> we would have used <code class="language-plaintext highlighter-rouge">A[1,1]</code>, then we will get an compilation error <code class="language-plaintext highlighter-rouge">print statement can only print scalars</code>.</p>

<h3 id="comments">Comments</h3>

<p>Two forms of commenting are supported: line and block comments. A line comment is indicated using a hash (<code class="language-plaintext highlighter-rouge">#</code>), and everything to the right of the hash is commented out. A block comment is indicated using &#8220;<code class="language-plaintext highlighter-rouge">/*</code>&#8221; to start the comment block and &#8220;<code class="language-plaintext highlighter-rouge">*/</code>&#8221; to end it.</p>

<h4 id="examples-1">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># this is an example of a line comment
/* this is an example of a
multi-line block comment
*/
</code></pre></div></div>

<hr />

<h2 id="expressions">Expressions</h2>

<p>Now that we have familiarized ourselves with variables and data type, let’s understand how to use them in expressions.</p>

<h3 id="operators">Operators</h3>

<p>SystemDS follows same associativity and precedence order as R as described in below table. The dimensions of the input matrices need to match the operator semantics, otherwise an exception will be raised at compile time. When one of the operands is a matrix and the other operand is a scalar value, the operation is performed cell-wise on the matrix using the scalar operand.</p>

<p><strong>Table 1</strong>: Operators</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Operator</th>
      <th>Input</th>
      <th>Output</th>
      <th>Details</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">^</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar<sup>1, 2</sup></td>
      <td>Exponentiation (right associativity) – Highest precedence</td>
    </tr>
    <tr>
      <td style="text-align: center">- +</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar<sup>1</sup></td>
      <td>Unary plus, minus</td>
    </tr>
    <tr>
      <td style="text-align: center">%*%</td>
      <td>Matrix</td>
      <td>Matrix</td>
      <td>Matrix multiplication</td>
    </tr>
    <tr>
      <td style="text-align: center">%/% %%</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar<sup>1, 2</sup></td>
      <td>Integer division and Modulus operator</td>
    </tr>
    <tr>
      <td style="text-align: center">/ *</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar<sup>1, 2</sup></td>
      <td>Multiplication and Division</td>
    </tr>
    <tr>
      <td style="text-align: center">+ -</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar<sup>1, 2</sup></td>
      <td>Addition (or string concatenation) and Subtraction</td>
    </tr>
    <tr>
      <td style="text-align: center">&lt; &gt; == != &lt;= &gt;=</td>
      <td>Matrix or Scalar (any value type)</td>
      <td>Matrix or Scalar<sup>1, 2</sup> (boolean type)</td>
      <td>Relational operators</td>
    </tr>
    <tr>
      <td style="text-align: center">&amp; | !</td>
      <td>Matrix or Scalar</td>
      <td>Matrix or Scalar</td>
      <td>Boolean operators (Note: operators &amp;&amp; and || are not supported)</td>
    </tr>
    <tr>
      <td style="text-align: center">=</td>
      <td>-</td>
      <td>-</td>
      <td>Assignment (Lowest precendence). Note: associativity of assignment &#8220;a = b = 3&#8221; is not supported</td>
    </tr>
  </tbody>
</table>

<p>1 If one of the operands is a matrix, output is matrix; otherwise it is scalar.</p>

<p>2 Support for Matrix-vector operations</p>

<h4 id="example">Example</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = matrix(1, rows=2,cols=2)
B = matrix(3, rows=2,cols=2)
C = 10
D = A %*% B + C * 2.1
print( "D[1,1]:" + as.scalar(D[1,1]))
</code></pre></div></div>

<p>Since matrix multiplication has higher precedence than scalar multiplication, which in turns has higher precedence than addition, the first cell of matrix <code class="language-plaintext highlighter-rouge">D</code> is evaluated as <code class="language-plaintext highlighter-rouge">((1*3)+(1*3))+(10*2.1) = 27.0</code>.</p>

<h3 id="matrix-vector-operations">Matrix-Vector Operations</h3>

<p>Arithmetic and relational operations described in above table support matrix-vector operations. This allows efficient cell-wise operations with either row or a column vector.</p>

<h4 id="syntax">Syntax</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input_Matrix operation Input_Vector
</code></pre></div></div>

<h4 id="example-1">Example</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M + V or M &gt; V, where M is a matrix and V is either row matrix or a column matrix.
</code></pre></div></div>

<p>Matrix-Vector operation avoids need for creating replicated matrix for certain subset of operations. For example: to compute class conditional probabilities in Naïve-Bayes, without support for matrix-vector operations, one might write below given inefficient script that creates unnecessary and possibly huge replicatedClassSums.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ones = matrix(1, rows=1, cols=numFeatures)
repClassSums = classSums %*% ones
class_conditionals = (classFeatureCounts + laplace_correction) / repClassSums
</code></pre></div></div>

<p>With support of matrix-vector operations, the above script becomes much more efficient as well as concise:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class_conditionals = (classFeatureCounts + laplace_correction) / classSums
</code></pre></div></div>

<h3 id="matrix-indexing">Matrix Indexing</h3>

<p>Each matrix has a specified number of rows and columns. A 1x1 matrix is not equivalent to a scalar double. The first index for both row and columns in a matrix is 1. For example, a matrix with 10 rows and 10 columns would have rows numbered 1 to 10, and columns numbered 1 to 10.</p>

<p>The elements of the matrix can be accessed by matrix indexing, with both row and column indices required. The indices must either be an expression evaluating to a positive numeric (integer or double) scalar value, or blank. To select the entire row or column of a matrix, leave the appropriate index blank. If a double value is used for indexing, the index value is implicitly cast to an integer with floor (value+eps) in order to account for double inaccuracy (see IEEE754, double precision, eps=pow(2,-53)).</p>

<h4 id="examples-2">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X[1,4] # access cell in row 1, column 4 of matrix X
X[i,j] # access cell in row i, column j of X.
X[1,]  # access the 1st row of X 
X[,2]  # access the 2nd column of X
X[,]   # access all rows and columns of X
</code></pre></div></div>

<p>Range indexing is supported to access a contiguous block of rows and columns in the matrix. The grammar for range-based indexing is below. The constraint is that lower-row &lt; upper-row, and lower-column &lt; upper-column.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Matrix name][lower-row : upper-row],[lower-column : upper-column]
</code></pre></div></div>

<h4 id="examples-3">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X[1:4, 1:4] # access the 4 x 4 submatrix comprising columns 1 – 4 of rows 1 – 4 of X
X[1:4, ]    # select the first 4 rows of X
X[1:, ]     # incorrect format
</code></pre></div></div>

<hr />

<h2 id="statements">Statements</h2>

<p>A script is a sequence of statements with the default computation semantics being sequential evaluation of the individual statements. The use of a semi-colon at the end of a statement is optional. The types of statements supported are</p>

<ul>
  <li>assignment,</li>
  <li>control structures (while, if, for), and</li>
  <li>user-defined function declaration.</li>
</ul>

<h3 id="assignment-statement">Assignment Statement</h3>

<p>An assignment statement consists of an expression, the result of which is assigned to a variable. The variable gets the appropriate data type (matrix or scalar) and value type (double, int, string, boolean) depending on the type of the variable output by the expression.</p>

<h4 id="examples-4">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># max_iteration is of type integer
max_iteration = 3;
# V has data type matrix and value type double.
V = W %*% H;
</code></pre></div></div>

<h3 id="control-statements">Control Statements</h3>

<h4 id="while-statement">While Statement</h4>

<p>The syntax for a while statement is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while (predicate) {
    statement1
    statement2
    ...
}
</code></pre></div></div>

<p>The statements in the while statement body are evaluated repeatedly until the predicate evaluates to TRUE. The while statement body must be surrounded by braces, even if the body only has a single statement.
The predicate in the while statement consist of operations on scalar variables and literals. The body of a while statement may contain any sequence of statements.</p>

<h5 id="example-2">Example</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ((i &lt; 20) &amp; (!converge)) {
    H = H * (t(W) %*% V) / (t(W) %*% W %*% H);
    W = W * (V %*% t(H)) / (W %*% H %*% t(H));
    i = i + 1;
}
</code></pre></div></div>

<h4 id="if-statement">If Statement</h4>

<p>The syntax for an if statement is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (predicate1) {
    statement1
    statement2
    ...
} [ else if (predicate2) {
    statement1
    statement2
    ...
} ] [ else {
    statement1
    statement2
    ...
} ]
</code></pre></div></div>

<p>The If statement has three bodies: the <code class="language-plaintext highlighter-rouge">if</code> body (evaluated if predicate1 evaluates to TRUE), the optional <code class="language-plaintext highlighter-rouge">else if</code> body (evaluated if predicate2 evaluates to TRUE) and the optional <code class="language-plaintext highlighter-rouge">else</code> body (evaluated otherwise). There can be multiple <code class="language-plaintext highlighter-rouge">else if</code> bodies with different predicates but at most one <code class="language-plaintext highlighter-rouge">else</code> body. The bodies may contain any sequence of statements. If only a single statement is enclosed in a body, the braces surrounding the statement can be omitted.</p>

<h5 id="examples-5">Examples</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># example of if statement
if (i &lt; 20) {
    converge = FALSE;
} else {
    converge = TRUE;
}
# example of nested control structures
while (!converge) {
    H = H * (t(W) %*% V) / (t(W) %*% W %*% H);
    W = W * (V %*% t(H)) / (W %*% H %*% t(H));
    i = i + 1;
    zerror = sum(z - W %*% H);
    if (zerror &lt; maxError) {
        converge = TRUE;
    } else {
        converge = FALSE;
    }
}
</code></pre></div></div>

<h4 id="for-statement">For Statement</h4>

<p>The syntax for a for statement is as follows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (var in &lt;for_predicate&gt; ) {
    &lt;statement&gt;*
}
&lt;for_predicate&gt; ::= [lower]:[upper] | seq ([lower], [upper], [increment])
</code></pre></div></div>

<p>var is an integer scalar variable. lower, upper, and increment are integer expressions.</p>

<p>Similarly, <code class="language-plaintext highlighter-rouge">seq([lower],[upper],[increment])</code> defines a sequence of numbers: {lower, lower + increment, lower + 2(increment), … }. For each element in the sequence, var is assigned the value, and statements in the for loop body are executed.</p>

<p>The for loop body may contain any sequence of statements. The statements in the for statement body must be surrounded by braces, even if the body only has a single statement.</p>

<h5 id="example-3">Example</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># example for statement
A = 5;
for (i in 1:20) {
    A = A + 1;
}
</code></pre></div></div>

<h4 id="parfor-statement">ParFor Statement</h4>

<p>The syntax and semantics of a <code class="language-plaintext highlighter-rouge">parfor</code> (parallel <code class="language-plaintext highlighter-rouge">for</code>) statement are equivalent to a <code class="language-plaintext highlighter-rouge">for</code> statement except for the different keyword and a list of optional parameters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parfor (var in &lt;for_predicate&gt; &lt;parfor_paramslist&gt; ) {
	&lt;statement&gt;*
}

&lt;parfor_paramslist&gt; ::= &lt;,&lt;parfor_parameter&gt;&gt;*
&lt;parfor_parameter&gt; ::
   = check = &lt;dependency_analysis&gt;
|| = par = &lt;degree_of_parallelism&gt;
|| = mode = &lt;execution_mode&gt;
|| = taskpartitioner = &lt;task_partitioning_algorithm&gt;
|| = tasksize = &lt;task_size&gt;
|| = datapartitioner = &lt;data_partitioning_mode&gt;
|| = resultmerge = &lt;result_merge_mode&gt;
|| = opt = &lt;optimization_mode&gt;
|| = log = &lt;log_level&gt;
|| = profile = &lt;monitor&gt;

&lt;dependency_analysis&gt;         0 1
&lt;degree_of_parallelism&gt;       arbitrary integer number
&lt;execution_mode&gt;              LOCAL REMOTE_SPARK REMOTE_SPARK_DP
&lt;task_partitioning_algorithm&gt; FIXED NAIVE STATIC FACTORING FACTORING_CMIN FACTORING_CMAX
&lt;task_size&gt;                   arbitrary integer number
&lt;data_partitioning_mode&gt;      NONE LOCAL REMOTE_SPARK
&lt;result_merge_mode&gt;           LOCAL_MEM LOCAL_FILE LOCAL_AUTOMATIC REMOTE_SPARK
&lt;optimization_mode&gt;           NONE RULEBASED CONSTRAINED HEURISTIC GREEDY FULL_DP
&lt;log_level&gt;                   ALL TRACE DEBUG INFO WARN ERROR FATAL OFF
&lt;monitor&gt;                     0 1
</code></pre></div></div>

<p>If any of these parameters is not specified, the following respective defaults are used:</p>

<p><strong>Table 2</strong>: Parfor default parameter values</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Default Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>check</td>
      <td>1</td>
    </tr>
    <tr>
      <td>par</td>
      <td>[number of virtual processors on master node]</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>LOCAL</td>
    </tr>
    <tr>
      <td>taskpartitioner</td>
      <td>FIXED</td>
    </tr>
    <tr>
      <td>tasksize</td>
      <td>1</td>
    </tr>
    <tr>
      <td>datapartitioner</td>
      <td>NONE</td>
    </tr>
    <tr>
      <td>resultmerge</td>
      <td>LOCAL_AUTOMATIC</td>
    </tr>
    <tr>
      <td>opt</td>
      <td>RULEBASED</td>
    </tr>
    <tr>
      <td>log</td>
      <td>INFO</td>
    </tr>
    <tr>
      <td>profile</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Of particular note is the <code class="language-plaintext highlighter-rouge">check</code> parameter. SystemDS&#8217;s <code class="language-plaintext highlighter-rouge">parfor</code> statement by default (<code class="language-plaintext highlighter-rouge">check = 1</code>) performs dependency analysis in an
attempt to guarantee result correctness for parallel execution. For example, the following <code class="language-plaintext highlighter-rouge">parfor</code> statement is <strong>incorrect</strong> because
the iterations do not act independently, so they are not parallelizable. The iterations incorrectly try to increment the same <code class="language-plaintext highlighter-rouge">sum</code> variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum = 0
parfor (i in 1:3) {
    sum = sum + i; # not parallelizable - generates error
}
print(sum)
</code></pre></div></div>

<p>SystemDS&#8217;s <code class="language-plaintext highlighter-rouge">parfor</code> dependency analysis can occasionally result in false positives, as in the following example. This example creates a 2x30
matrix. It then utilizes a <code class="language-plaintext highlighter-rouge">parfor</code> loop to write 10 2x3 matrices into the 2x30 matrix. This <code class="language-plaintext highlighter-rouge">parfor</code> statement is parallelizable and correct,
but the dependency analysis generates a false positive dependency error for the variable <code class="language-plaintext highlighter-rouge">ms</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ms = matrix(0, rows=2, cols=3*10)
parfor (v in 1:10) { # parallelizable - false positive
    mv = matrix(v, rows=2, cols=3)
    ms[,(v-1)*3+1:v*3] = mv
}
</code></pre></div></div>

<p>If a false positive arises but you are certain that the <code class="language-plaintext highlighter-rouge">parfor</code> is parallelizable, the <code class="language-plaintext highlighter-rouge">parfor</code> dependency check can be disabled via
the <code class="language-plaintext highlighter-rouge">check = 0</code> option.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ms = matrix(0, rows=2, cols=3*10)
parfor (v in 1:10, check=0) { # parallelizable
    mv = matrix(v, rows=2, cols=3)
    ms[,(v-1)*3+1:v*3] = mv
}
</code></pre></div></div>

<p>While developing DML scripts or debugging, it can be useful to <strong>turn off <code class="language-plaintext highlighter-rouge">parfor</code> parallelization</strong>. This can be accomplished in the following
three ways:</p>

<ol>
  <li>Replace <code class="language-plaintext highlighter-rouge">parfor()</code> with <code class="language-plaintext highlighter-rouge">for()</code>. Since <code class="language-plaintext highlighter-rouge">parfor</code> is derived from <code class="language-plaintext highlighter-rouge">for</code>, you can always use <code class="language-plaintext highlighter-rouge">for</code> wherever you can use <code class="language-plaintext highlighter-rouge">parfor</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">parfor(opt = NONE, par = 1, ...)</code>. This disables optimization, uses defaults, and overwrites the specified parameters.</li>
  <li><code class="language-plaintext highlighter-rouge">parfor(opt = CONSTRAINED, par = 1, ...)</code>. This optimizes using the specified parameters.</li>
</ol>

<h3 id="user-defined-function-udf">User-Defined Function (UDF)</h3>

<p>The UDF function declaration statement provides the function signature, which defines the formal parameters used to call the function and return values for the function. The function definition specifies the function implementation, and can either be a sequence of statements or external packages / libraries. If the UDF is implemented in a SystemDS script, then UDF declaration and definition occur together.</p>

<p>The syntax for the UDF function declaration is given as follows. The function definition is stored as a list of statements in the function body. The explanation of the parameters is given below. Any statement can be placed inside a UDF definition except UDF function declaration statements. The variables specified in the return clause will be returned, and no explicit return statement within the function body is required.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functionName = function([ &lt;DataType&gt;? &lt;ValueType&gt; &lt;var&gt;, ]* )
    return ([ &lt;DataType&gt;? &lt;ValueType&gt; &lt;var&gt;,]*) {
    # function body definition in DML
    statement1
    statement2
    ...
}
</code></pre></div></div>

<p>The syntax for the UDF function declaration for functions defined in external packages/ ibraries is given as follows. The parameters are explained below. The main difference is that a user must specify the appropriate collection of userParam=value pairs for the given external package. Also, one of the userParam should be ’classname’.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functionName = externalFunction(
    [&lt;DataType&gt;? &lt;ValueType&gt; &lt;var&gt;, ]* )
return ([&lt;DataType&gt;? &lt;ValueType&gt; &lt;var&gt;,]*)
implemented in ([userParam=value]*)
</code></pre></div></div>

<p><strong>Table 3</strong>: Parameters for UDF Function Definition Statements</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Description</th>
      <th>Optional</th>
      <th>Permissible Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>functionName</td>
      <td>Name of the function.</td>
      <td>No</td>
      <td>Any non-keyword string</td>
    </tr>
    <tr>
      <td>DataType</td>
      <td>The data type of the identifier for a formal parameter or return value.</td>
      <td>If the value value is scalar or object, then DataType is optional</td>
      <td>matrix, scalar, object (capitalization does not matter)</td>
    </tr>
    <tr>
      <td>ValueType</td>
      <td>The value type of the identifier for a formal parameter or return value.</td>
      <td>No. The value type object can only use used with data type object.</td>
      <td>double, integer, string, boolean, object</td>
    </tr>
    <tr>
      <td>Var</td>
      <td>The identifier for a formal parameter or return value.</td>
      <td>No</td>
      <td>Any non-keyword sting</td>
    </tr>
    <tr>
      <td>userParam=value</td>
      <td>User-defined parameter to invoke the package.</td>
      <td>Yes</td>
      <td>Any non-keyword string</td>
    </tr>
  </tbody>
</table>

<h4 id="examples-6">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># example of a UDF defined in DML
mean = function (matrix[double] A) return (double m) {
    m = sum(A)/nrow(A)
}

# example of a UDF defined in DML with multiple return values
minMax = function( matrix[double] M) return (double minVal, double maxVal) {
    minVal = min(M);
    maxVal = max(M);
}

# example of an external UDF
time = externalFunction(Integer i) return (Double B)
       implemented in (classname="org.apache.sysds.udf.lib.TimeWrapper", exectype="mem");
t = time(1);
print("Time: " + t);
</code></pre></div></div>

<p>A UDF invocation specifies the function identifier, variable identifiers for calling parameters, and the variables to be populated by the returned values from the function. The syntax for function calls is as follows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>returnVal = functionName(param1, param2, ...)
[returnVal1, returnVal2, ...] = functionName(param1, param2, ...)
</code></pre></div></div>

<h4 id="examples-7">Examples</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># DML script with a function call
B = matrix(0, rows = 10,cols = 10);
C = matrix(0, rows = 100, cols = 100);
D = addEach(1, C);
index = 0;
while (index &lt; 5) {
    [minD, maxD] = minMax(D);
    index = index + 1
}
</code></pre></div></div>

<h2 id="variable-scoping">Variable Scoping</h2>

<p>DML supports following two types of scoping:</p>
<ol>
  <li>Default: All the variables are bound to global unbounded scope.</li>
  <li>Function scope: Only the variables specified in the function declaration can be accessed inside function.</li>
</ol>

<p>Note: The command-line parameters are treated as constants which are introduced during parse-time.</p>

<h3 id="example-of-default-scope">Example of Default Scope</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(1!=0) {
    A = 1;
}
print("A:" + A);
</code></pre></div></div>

<p>This will result in parser warning, but the program will run to completion. If the expression in the &#8220;if&#8221; predicate would have evaluated to FALSE, it would have resulted in runtime error. Also, functions need not be defined prior to its call. That is: following code will work without parser warning:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = 2;
C = foo(1, A)
print("C:" + C);
foo = function(double A, double B) return (double C) {
    C = A + B;
}
</code></pre></div></div>

<h3 id="example-of-function-scope">Example of Function Scope</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = 2;
D = 1;
foo = function(double A, double B) return (double C) {
    A = 3.0; # value of global A won’t change since it is pass by value

    C = A + B # Note: C = A + D will result in compilation error
}
C = foo(A, 1)
print("C:" + C + " A:" + A);
</code></pre></div></div>

<p>The above code will output: <code class="language-plaintext highlighter-rouge">C:4.0 A:2</code></p>

<h2 id="command-line-arguments">Command-Line Arguments</h2>

<p>Since most algorithms require arguments to be passed from command line, DML supports command-line arguments. The command line parameters are treated as constants (similar to arguments passed to main function of a java program). The command line parameters can be passed in two ways:</p>

<ol>
  <li>
    <p>As named arguments (recommended):</p>

    <p><code class="language-plaintext highlighter-rouge">-nvargs param1=7 param2="abc" param3=3.14</code></p>
  </li>
  <li>
    <p>As positional arguments (deprecated):</p>

    <p><code class="language-plaintext highlighter-rouge">-args 7 "abc" 3.14</code></p>
  </li>
</ol>

<p>The named arguments can be accessed by adding &#8220;\$&#8221; before the parameter name, i.e. \$param1. On the other hand, the positional parameter are accessible by adding &#8220;\$&#8221; before their positions (starting from index 1), i.e. \$1. A string parameter can be passed without quote. For example, <code class="language-plaintext highlighter-rouge">param2=abc</code> is valid argument, but it is not recommend.</p>

<p>Sometimes the user would want to support default values in case user does not explicitly pass the corresponding command line parameter (in below example: <code class="language-plaintext highlighter-rouge">$nbrRows</code>). To do so, we use the <code class="language-plaintext highlighter-rouge">ifdef</code> function which assigns either command line parameter or the default value to the local parameter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local_variable = ifdef(command line variable, default value)
</code></pre></div></div>

<h3 id="example-script-in-file-testdml">Example: Script in file test.dml</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>localVar_nbrRows=ifdef($nbrRows , 10)
M = rand (rows = localVar_nbrRows, cols = $nbrCols)
write (M, $fname, format="csv")
print("Done creating and writing random matrix in " + $fname)
</code></pre></div></div>

<p>In above script, <code class="language-plaintext highlighter-rouge">ifdef(\$nbrRows, 10)</code> function is a short-hand for &#8220;<code class="language-plaintext highlighter-rouge">ifdef(\$nbrRows) then \$nbrRows else 10</code>&#8221;.</p>

<p>Let’s assume that the above script is invoked using following the command line values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spark-submit SystemDS.jar -f test.dml -nvargs fname=test.mtx nbrRows=5 nbrCols=5
</code></pre></div></div>

<p>In this case, the script will create a random matrix M with 5 rows and 5 columns and write it to the file &#8220;text.mtx&#8221; in csv format. After that it will print the message &#8220;Done creating and writing random matrix in test.mtx&#8221; on the standard output.</p>

<p>If however, the above script is invoked from the command line using named arguments:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spark-submit SystemDS.jar -f test.dml -nvargs fname=test.mtx nbrCols=5
</code></pre></div></div>

<p>Then, the script will instead create a random matrix M with 10 rows (i.e. default value provided in the script) and 5 columns.</p>

<p>It is important to note that the placeholder variables should be treated like constants that are initialized once, either via command line-arguments or via default values at the beginning of the script.</p>

<p>Each argValue passed from the command-line has a scalar data type, and the value type for argValue is inferred using the following logic:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (argValue can be cast as Integer)
    Assign argValue integer value type
else if (argValue can be cast as Double)
    Assign argValue double value type
else if (argValue can be cast as Boolean)
    Assign argValue boolean value type
else
    Assign argValue string value type
</code></pre></div></div>

<p>In above example, the placeholder variable <code class="language-plaintext highlighter-rouge">\$nbrCols</code> will be treated as integer in the script. If however, the command line arguments were &#8220;<code class="language-plaintext highlighter-rouge">nbrCols=5.0</code>&#8221;, then it would be treated as a double.</p>

<p>NOTE: argName must be a valid identifier.
NOTE: If argValue contains spaces, it must be enclosed in double-quotes.
NOTE: The values passed from the command-line are passed as literal values which replace the placeholders in the DML script, and are not interpreted as DML.</p>

<h2 id="built-in-functions">Built-In Functions</h2>

<p>Built-in functions are categorized in:</p>

<ul>
  <li>Matrix Construction, Manipulation, and Aggregation Built-In Functions</li>
  <li>Matrix and/or Scalar Comparison Built-In Functions</li>
  <li>Casting Built-In Functions</li>
  <li>Statistical Built-In Functions</li>
  <li>Mathematical and Trigonometric Built-In Functions</li>
  <li>Linear Algebra Built-In Functions</li>
  <li>Other Built-In Functions</li>
</ul>

<p>The tables below list the supported built-in functions.
For example, consider the following expressions:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s = sum(A);
B = rowSums(A);
C = colSums(A);
D = rowSums(C);
diff = s – as.scalar(D);
</code></pre></div></div>

<p>The builtin function <code class="language-plaintext highlighter-rouge">sum</code> operates on a matrix (say A of dimensionality (m x n)) and returns a scalar value corresponding to the sum of all values in the matrix. The built-in functions <code class="language-plaintext highlighter-rouge">rowSums</code> and <code class="language-plaintext highlighter-rouge">colSums</code>, on the other hand, aggregate values on a per-row and per-column basis respectively. They output matrices of dimensionality (m x 1) and 1xn, respectively. Therefore, B is a m x 1 matrix and C is a 1 x n matrix. Applying <code class="language-plaintext highlighter-rouge">rowSums</code> on matrix C, we obtain matrix D as a 1 x 1 matrix. A 1 x 1 matrix is different from a scalar; to treat D as a scalar, an explicit <code class="language-plaintext highlighter-rouge">as.scalar</code> operation is invoked in the final statement. The difference between s and <code class="language-plaintext highlighter-rouge">as.scalar(D)</code> should be 0.</p>

<h3 id="matrix-construction-manipulation-and-aggregation-built-in-functions">Matrix Construction, Manipulation, and Aggregation Built-In Functions</h3>

<p><strong>Table 4</strong>: Matrix Construction, Manipulation, and Aggregation Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cbind()</td>
      <td>Column-wise matrix concatenation (concatenates the second matrix as additional columns to the first matrix). This operation also supports nary inputs, i.e., more than 2 input matrices.</td>
      <td>Input: (X &lt;matrix&gt;, Y &lt;matrix&gt;) <br />Output: &lt;matrix&gt; <br /> X and Y are matrices, where the number of rows in X and the number of rows in Y are the same.</td>
      <td>A = matrix(1, rows=2,cols=3) <br /> B = matrix(2, rows=2,cols=3) <br /> C = cbind(A,B) <br /> print(&#8220;Dimensions of C: &#8220; + nrow(C) + &#8220; X &#8220; + ncol(C)) <br /> Output: <br /> Dimensions of C: 2 X 6</td>
    </tr>
    <tr>
      <td>lower.tri()</td>
      <td>Selects the lower triangular part of a matrix, configurable to include the diagonal and return values or ones.</td>
      <td>Input : (target= X &lt;matrix&gt; [, diag=FALSE][, values=FALSE]) <br /> Output : &lt;matrix&gt;</td>
      <td>A = lower.tri(target=X, diag=TRUE, values=TRUE)</td>
    </tr>
    <tr>
      <td>matrix()</td>
      <td>Matrix constructor (assigning all the cells to numeric literals).</td>
      <td>Input: (&lt;init&gt;, rows=&lt;value&gt;, cols=&lt;value&gt;) <br /> init: numeric literal; <br /> rows/cols: number of rows/cols (expression) <br /> Output: matrix</td>
      <td># 10x10 matrix initialized to 0 <br /> A = matrix (0, rows=10, cols=10)</td>
    </tr>
    <tr>
      <td>&#160;</td>
      <td>Matrix constructor (reshaping an existing matrix).</td>
      <td>Input: (&lt;existing matrix&gt;, rows=&lt;value&gt;, cols=&lt;value&gt;, byrow=TRUE) <br /> Output: matrix</td>
      <td>A = matrix (0, rows=10, cols=10) <br /> B = matrix (A, rows=100, cols=1)</td>
    </tr>
    <tr>
      <td>&#160;</td>
      <td>Matrix constructor (initializing using string).</td>
      <td>Input: (&lt;initialization string&gt;, rows=&lt;value&gt;, cols=&lt;value&gt;) <br /> Output: matrix</td>
      <td>A = matrix(&#8220;4 3 2 5 7 8&#8221;, rows=3, cols=2) <br /> Creates a matrix: [ [4, 3], [2, 5], [7, 8] ]</td>
    </tr>
    <tr>
      <td>min() <br /> max()</td>
      <td>Return the minimum/maximum cell value in matrix</td>
      <td>Input: matrix <br /> Output: scalar</td>
      <td>min(X) <br /> max(Y)</td>
    </tr>
    <tr>
      <td>min() <br /> max()</td>
      <td>Return the minimum/maximum cell values of two matrices, matrix and scalar, or scalar value of two scalars.</td>
      <td>Input: matrices or scalars <br /> Output: matrix or scalar</td>
      <td>With x,y, z as scalars, and X, Y, Z as matrices: <br /> Z = min (X, Y) <br /> Z = min (X, y) <br /> z = min(x,y)</td>
    </tr>
    <tr>
      <td>nrow(), <br /> ncol(), <br /> length()</td>
      <td>Return the number of rows, number of columns, or number of cells in matrix or frame respectively.</td>
      <td>Input: matrix or frame <br /> Output: scalar</td>
      <td>nrow(X) <br /> ncol(F) <br /> length(X)</td>
    </tr>
    <tr>
      <td>prod()</td>
      <td>Return the product of all cells in matrix</td>
      <td>Input: matrix <br /> Output: scalarj</td>
      <td>prod(X)</td>
    </tr>
    <tr>
      <td>rand()</td>
      <td>Generates a random matrix</td>
      <td>Input: (rows=&lt;value&gt;, cols=&lt;value&gt;, min=&lt;value&gt;, max=&lt;value&gt;, sparsity=&lt;value&gt;, pdf=&lt;string&gt;, seed=&lt;value&gt;) <br /> rows/cols: Number of rows/cols (expression) <br /> min/max: Min/max value for cells (either constant value, or variable that evaluates to constant value) <br /> sparsity: fraction of non-zero cells (constant value) <br /> pdf: &#8220;uniform&#8221; (min, max) distribution, or &#8220;normal&#8221; (0,1) distribution; or &#8220;poisson&#8221; (lambda=1) distribution. string; default value is &#8220;uniform&#8221;. Note that, for the Poisson distribution, users can provide the mean/lambda parameter as follows: <br /> rand(rows=1000,cols=1000, pdf=&#8221;poisson&#8221;, lambda=2.5). <br /> The default value for lambda is 1. <br /> seed: Every invocation of rand() internally generates a random seed with which the cell values are generated. One can optionally provide a seed when repeatability is desired. If the seed is set to -1 a random seed will still be generated. <br /> Output: matrix</td>
      <td>X = rand(rows=10, cols=20, min=0, max=1, pdf=&#8221;uniform&#8221;, sparsity=0.2) <br /> The example generates a 10 x 20 matrix, with cell values uniformly chosen at random between 0 and 1, and approximately 20% of cells will have non-zero values.</td>
    </tr>
    <tr>
      <td>rbind()</td>
      <td>Row-wise matrix concatenation (concatenates the second matrix as additional rows to the first matrix). This operation also supports nary inputs, i.e., more than 2 input matrices.</td>
      <td>Input: (X &lt;matrix&gt;, Y &lt;matrix&gt;) <br />Output: &lt;matrix&gt; <br /> X and Y are matrices, where the number of columns in X and the number of columns in Y are the same.</td>
      <td>A = matrix(1, rows=2,cols=3) <br /> B = matrix(2, rows=2,cols=3) <br /> C = rbind(A,B) <br /> print(&#8220;Dimensions of C: &#8220; + nrow(C) + &#8220; X &#8220; + ncol(C)) <br /> Output: <br /> Dimensions of C: 4 X 3</td>
    </tr>
    <tr>
      <td>removeEmpty()</td>
      <td>Removes all empty rows or columns from the input matrix target X according to the specified margin. The optional select vector F specifies selected rows or columns; if not provided, the semantics are F=(rowSums(X!=0)&gt;0) and F=(colSums(X!=0)&gt;0) for removeEmpty &#8220;rows&#8221; and &#8220;cols&#8221;, respectively. The optional empty.return flag indicates if a row or column of zeros should be returned for empty inputs.</td>
      <td>Input : (target= X &lt;matrix&gt;, margin=&#8221;&#8230;&#8221;[, select=F][, empty.return=TRUE]) <br /> Output : &lt;matrix&gt; <br /> Valid values for margin are &#8220;rows&#8221; or &#8220;cols&#8221;.</td>
      <td>A = removeEmpty(target=X, margin=&#8221;rows&#8221;, select=F)</td>
    </tr>
    <tr>
      <td>replace()</td>
      <td>Creates a copy of input matrix X, where all values that are equal to the scalar pattern s1 are replaced with the scalar replacement s2.</td>
      <td>Input : (target= X &lt;matrix&gt;, pattern=&lt;scalar&gt;, replacement=&lt;scalar&gt;) <br /> Output : &lt;matrix&gt; <br /> If s1 is NaN, then all NaN values of X are treated as equal and hence replaced with s2. Positive and negative infinity are treated as different values.</td>
      <td>A = replace(target=X, pattern=s1, replacement=s2)</td>
    </tr>
    <tr>
      <td>rev()</td>
      <td>Reverses the rows in a matrix</td>
      <td>Input : (&lt;matrix&gt;) <br /> Output : &lt;matrix&gt;</td>
      <td><span style="white-space: nowrap;">A = matrix(&#8220;1 2 3 4&#8221;, rows=2, cols=2)</span> <br /> <span style="white-space: nowrap;">B = matrix(&#8220;1 2 3 4&#8221;, rows=4, cols=1)</span> <br /> <span style="white-space: nowrap;">C = matrix(&#8220;1 2 3 4&#8221;, rows=1, cols=4)</span> <br /> revA = rev(A) <br /> revB = rev(B) <br /> revC = rev(C) <br /> Matrix revA: [[3, 4], [1, 2]]<br /> Matrix revB: [[4], [3], [2], [1]]<br /> Matrix revC: [[1, 2, 3, 4]]<br /></td>
    </tr>
    <tr>
      <td>seq()</td>
      <td>Creates a single column vector with values starting from &lt;from&gt;, to &lt;to&gt;, in increments of &lt;increment&gt;</td>
      <td>Input: (&lt;from&gt;, &lt;to&gt;, &lt;increment&gt;) <br /> Output: &lt;matrix&gt;</td>
      <td>S = seq (10, 200, 10)</td>
    </tr>
    <tr>
      <td>sum()</td>
      <td>Sum of all cells in matrix</td>
      <td>Input: matrix <br /> Output: scalar</td>
      <td>sum(X)</td>
    </tr>
    <tr>
      <td>upper.tri()</td>
      <td>Selects the upper triangular part of a matrix, configurable to include the diagonal and return values or ones.</td>
      <td>Input : (target= X &lt;matrix&gt; [, diag=FALSE][, values=FALSE]) <br /> Output : &lt;matrix&gt;</td>
      <td>A = upper.tri(target=X, diag=TRUE, values=TRUE)</td>
    </tr>
  </tbody>
</table>

<h3 id="matrix-andor-scalar-comparison-built-in-functions">Matrix and/or Scalar Comparison Built-In Functions</h3>

<p><strong>Table 5</strong>: Matrix and/or Scalar Comparison Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>is.na()</td>
      <td>Computes a boolean indicator matrix of the same shape as the input, indicating where NA (not available) values are located. Currently NA is only capturing NaN values. Alternative name: isNA()</td>
      <td>Input: &lt;matrix&gt;,<br /> Output: boolean &lt;matrix&gt;</td>
      <td>isNA(X)</td>
    </tr>
    <tr>
      <td>is.nan()</td>
      <td>Computes a boolean indicator matrix of the same shape as the input, indicating where NaN (not a number) values are located. Alternative name: isNaN()</td>
      <td>Input: &lt;matrix&gt;,<br /> Output: boolean &lt;matrix&gt;</td>
      <td>isNaN(X)</td>
    </tr>
    <tr>
      <td>is.infinite()</td>
      <td>Computes a boolean indicator matrix of the same shape as the input, indicating where Inf (positive or negative infinity) values are located. Alternative name: isInf()</td>
      <td>Input: &lt;matrix&gt;,<br /> Output: boolean &lt;matrix&gt;</td>
      <td>isInf(X)</td>
    </tr>
    <tr>
      <td>pmin() <br /> pmax()</td>
      <td>&#8220;parallel min/max&#8221;.<br /> Return cell-wise minimum/maximum. If the second input is a scalar then it is compared against all cells in the first input.</td>
      <td>Input: (&lt;matrix&gt;, &lt;matrix&gt;), or (&lt;matrix&gt;, &lt;scalar&gt;) <br /> Output: matrix</td>
      <td>pmin(X,Y) <br /> pmax(X,y)</td>
    </tr>
    <tr>
      <td>rowIndexMax()</td>
      <td>Row-wise computation &#8211; for each row, find the max value, and return its column index.</td>
      <td>Input: (matrix) <br /> Output: (n x 1) matrix</td>
      <td>rowIndexMax(X)</td>
    </tr>
    <tr>
      <td>rowIndexMin()</td>
      <td>Row-wise computation &#8211; for each row, find the minimum value, and return its column index.</td>
      <td>Input: (matrix) <br /> Output: (n x 1) matrix</td>
      <td>rowIndexMin(X)</td>
    </tr>
    <tr>
      <td>xor()</td>
      <td>Boolean XOR operation with the following cell-wise semantics: (X!=0) XOR (Y!=0).</td>
      <td>Input: matrices or scalars <br /> Output: matrix or scalar</td>
      <td>xor(X, Y)</td>
    </tr>
    <tr>
      <td>ppred()</td>
      <td>&#8220;parallel predicate&#8221;.<br /> The relational operator specified in the third argument is cell-wise applied to input matrices. If the second argument is a scalar, then it is used against all cells in the first argument. <br /> <strong>NOTE: ppred() has been replaced by the relational operators, so its use is discouraged.</strong></td>
      <td>Input: (&lt;matrix&gt;, &lt;matrix&gt;, &lt;string with relational operator&gt;), or <br /> (&lt;matrix&gt;, &lt;scalar&gt;, &lt;string with relational operator&gt;) <br /> Output: matrix</td>
      <td>ppred(X,Y,&#8221;&lt;&#8221;) <br /> ppred(X,y,&#8221;&lt;&#8221;)</td>
    </tr>
  </tbody>
</table>

<h3 id="casting-built-in-functions">Casting Built-In Functions</h3>

<p><strong>Table 6</strong>: Casting Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>as.scalar(), <br /> as.matrix()</td>
      <td>A 1x1 matrix is cast as scalar (value type preserving), and a scalar is cast as 1x1 matrix with value type double</td>
      <td>Input: (&lt;matrix&gt;), or (&lt;scalar&gt;) <br /> Output: &lt;scalar&gt;, or &lt;matrix&gt;</td>
      <td>as.scalar(X) <br /> as.matrix(x)</td>
    </tr>
    <tr>
      <td>as.double(), <br /> as.integer(), <br /> as.logical()</td>
      <td>A variable is cast as the respective value type, data type preserving. as.integer() performs a safe cast. For numerical inputs, as.logical() returns FALSE if the input value is 0 or 0.0, and TRUE otherwise.</td>
      <td>Input: (&lt;scalar&gt;) <br /> Output: &lt;scalar&gt;</td>
      <td>as.double(X) <br /> as.integer(x) <br /> as.logical(y)</td>
    </tr>
  </tbody>
</table>

<h3 id="statistical-built-in-functions">Statistical Built-In Functions</h3>

<p><strong>Table 7</strong>: Statistical Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>mean() <br /> avg()</td>
      <td>Return the mean value of all cells in matrix</td>
      <td>Input: matrix <br /> Output: scalar</td>
      <td>mean(X)</td>
    </tr>
    <tr>
      <td>var() <br /> sd()</td>
      <td>Return the variance/stdDev value of all cells in matrix. Both use unbiased estimators with (n-1) denominator.</td>
      <td>Input: matrix <br /> Output: scalar</td>
      <td>var(X) <br /> sd(X)</td>
    </tr>
    <tr>
      <td>moment()</td>
      <td>Returns the kth central moment of values in a column matrix V, where k = 2, 3, or 4. It can be used to compute statistical measures like Variance, Kurtosis, and Skewness. This function also takes an optional weights parameter W.</td>
      <td>Input: (X &lt;(n x 1) matrix&gt;, [W &lt;(n x 1) matrix&gt;),] k &lt;scalar&gt;) <br /> Output: &lt;scalar&gt;</td>
      <td>A = rand(rows=100000,cols=1, pdf=&#8221;normal&#8221;) <br /> print(&#8220;Variance from our (standard normal) random generator is approximately &#8220; + moment(A,2))</td>
    </tr>
    <tr>
      <td>colSums() <br /> colMeans() <br /> colVars() <br /> colSds() <br /> colMaxs() <br /> colMins()</td>
      <td>Column-wise computations &#8211; for each column, compute the sum/mean/variance/stdDev/max/min of cell values</td>
      <td>Input: matrix <br /> Output: (1 x n) matrix</td>
      <td>colSums(X) <br /> colMeans(X) <br /> colVars(X) <br /> colSds(X) <br /> colMaxs(X) <br />colMins(X)</td>
    </tr>
    <tr>
      <td>cov()</td>
      <td>Returns the covariance between two 1-dimensional column matrices X and Y. The function takes an optional weights parameter W. All column matrices X, Y, and W (when specified) must have the exact same dimension.</td>
      <td>Input: (X &lt;(n x 1) matrix&gt;, Y &lt;(n x 1) matrix&gt; [, W &lt;(n x 1) matrix&gt;)]) <br /> Output: &lt;scalar&gt;</td>
      <td>cov(X,Y) <br /> cov(X,Y,W)</td>
    </tr>
    <tr>
      <td>contains()</td>
      <td>Indicates if the target matrix contains at least one pattern value (with handling of special values like Not-a-Number).</td>
      <td>Input: (target=&lt;matrix&gt;,pattern=&lt;scalar&gt;)<br /> Output: &lt;scalar&gt;</td>
      <td>hasNaNs = contains(target=X, pattern=NaN)</td>
    </tr>
    <tr>
      <td>table()</td>
      <td>Returns the contingency table of two vectors A and B. The resulting table F consists of max(A) rows and max(B) columns. <br /> More precisely, F[i,j] = |{ k | A[k] = i and B[k] = j, 1 ≤ k ≤ n }|, where A and B are two n-dimensional vectors. <br /> This function supports multiple other variants, which can be found below, at the end of this Table 7.</td>
      <td>Input: (&lt;(n x 1) matrix&gt;, &lt;(n x 1) matrix&gt;), [&lt;(n x 1) matrix&gt;]) <br /> Output: &lt;matrix&gt;</td>
      <td>F = table(A, B) <br /> F = table(A, B, C) <br /> And, several other forms (see below Table 7.)</td>
    </tr>
    <tr>
      <td>cdf()<br /> pnorm()<br /> pexp()<br /> pchisq()<br /> pf()<br /> pt()<br /> icdf()<br /> qnorm()<br /> qexp()<br /> qchisq()<br /> qf()<br /> qt()</td>
      <td>p=cdf(target=q, &#8230;) returns the cumulative probability P[X &lt;= q]. <br /> q=icdf(target=p, &#8230;) returns the inverse cumulative probability i.e., it returns q such that the given target p = P[X&lt;=q]. <br /> For more details, please see the section &#8220;Probability Distribution Functions&#8221; below Table 7.</td>
      <td>Input: (target=&lt;scalar&gt;, dist=&#8221;&#8230;&#8221;, &#8230;) <br /> Output: &lt;scalar&gt;</td>
      <td>p = cdf(target=q, dist=&#8221;normal&#8221;, mean=1.5, sd=2); is same as p=pnorm(target=q, mean=1.5, sd=2); <br /> q=icdf(target=p, dist=&#8221;normal&#8221;) is same as q=qnorm(target=p, mean=0,sd=1) <br /> More examples can be found in the section &#8220;Probability Distribution Functions&#8221; below Table 7.</td>
    </tr>
    <tr>
      <td>aggregate()</td>
      <td>Splits/groups the values from X according to the corresponding values from G, and then applies the function fn on each group. <br /> The result F is a column matrix, in which each row contains the value computed from a distinct group in G. More specifically, F[k,1] = fn( {X[i,1] | 1&lt;=i&lt;=n and G[i,1] = k} ), where n = nrow(X) = nrow(G). <br /> Note that the distinct values in G are used as row indexes in the result matrix F. Therefore, nrow(F) = max(G). It is thus recommended that the values in G are consecutive and start from 1. <br /> This function supports multiple other variants, which can be found below, at the end of this Table 7.</td>
      <td>Input:<br /> (target = X &lt;(n x 1) matrix, or matrix&gt;,<br /> &#160;&#160;&#160;groups = G &lt;(n x 1) matrix&gt;,<br /> &#160;&#160;&#160;fn= &#8220;&#8230;&#8221; <br /> &#160;&#160;&#160;[,weights= W&lt;(n x 1) matrix&gt;] <br /> &#160;&#160;&#160;[,ngroups=N] )<br />Output: F &lt;matrix&gt; <br /> Note: X is a (n x 1) matrix unless ngroups is specified with no weights, in which case X is a regular (n x m) matrix.<br /> The parameter fn takes one of the following functions: &#8220;count&#8221;, &#8220;sum&#8221;, &#8220;mean&#8221;, &#8220;variance&#8221;, &#8220;centralmoment&#8221;. In the case of central moment, one must also provide the order of the moment that need to be computed (see example).</td>
      <td>F = aggregate(target=X, groups=G, fn= &#8220;&#8230;&#8221; [,weights = W]) <br /> F = aggregate(target=X, groups=G1, fn= &#8220;sum&#8221;); <br /> F = aggregate(target=Y, groups=G2, fn= &#8220;mean&#8221;, weights=W); <br /> F = aggregate(target=Z, groups=G3, fn= &#8220;centralmoment&#8221;, order= &#8220;2&#8221;); <br /> And, several other forms (see below Table 7.)</td>
    </tr>
    <tr>
      <td>interQuartileMean()</td>
      <td>Returns the mean of all x in X such that x&gt;quantile(X, 0.25) and x&lt;=quantile(X, 0.75). X, W are column matrices (vectors) of the same size. W contains the weights for data in X.</td>
      <td>Input: (X &lt;(n x 1) matrix&gt; [, W &lt;(n x 1) matrix&gt;)]) <br /> Output: &lt;scalar&gt;</td>
      <td>interQuartileMean(X) <br /> interQuartileMean(X, W)</td>
    </tr>
    <tr>
      <td>quantile ()</td>
      <td>The p-quantile for a random variable X is the value x such that Pr[X&lt;x] &lt;= p and Pr[X&lt;= x] &gt;= p <br /> let n=nrow(X), i=ceiling(p*n), quantile() will return X[i]. p is a scalar (0&lt;p&lt;1) that specifies the quantile to be computed. Optionally, a weight vector may be provided for X.</td>
      <td>Input: (X &lt;(n x 1) matrix&gt;, [W &lt;(n x 1) matrix&gt;),] p &lt;scalar&gt;) <br /> Output: &lt;scalar&gt;</td>
      <td>quantile(X, p) <br /> quantile(X, W, p)</td>
    </tr>
    <tr>
      <td>quantile ()</td>
      <td>Returns a column matrix with list of all quantiles requested in P.</td>
      <td>Input: (X &lt;(n x 1) matrix&gt;, [W &lt;(n x 1) matrix&gt;),] P &lt;(q x 1) matrix&gt;) <br /> Output: matrix</td>
      <td>quantile(X, P) <br /> quantile(X, W, P)</td>
    </tr>
    <tr>
      <td>median()</td>
      <td>Computes the median in a given column matrix of values</td>
      <td>Input: (X &lt;(n x 1) matrix&gt;, [W &lt;(n x 1) matrix&gt;),]) <br /> Output: &lt;scalar&gt;</td>
      <td>median(X) <br /> median(X,W)</td>
    </tr>
    <tr>
      <td>rowSums() <br /> rowMeans() <br /> rowVars() <br /> rowSds() <br /> rowMaxs() <br /> rowMins()</td>
      <td>Row-wise computations &#8211; for each row, compute the sum/mean/variance/stdDev/max/min of cell value</td>
      <td>Input: matrix <br /> Output: (n x 1) matrix</td>
      <td>rowSums(X) <br /> rowMeans(X) <br /> rowVars(X) <br /> rowSds(X) <br /> rowMaxs(X) <br /> rowMins(X)</td>
    </tr>
    <tr>
      <td>cumsum()</td>
      <td>Column prefix-sum (For row-prefix sum, use cumsum(t(X))</td>
      <td>Input: matrix <br /> Output: matrix of the same dimensions</td>
      <td>A = matrix(&#8220;1 2 3 4 5 6&#8221;, rows=3, cols=2) <br /> B = cumsum(A) <br /> The output matrix B = [[1, 2], [4, 6], [9, 12]]</td>
    </tr>
    <tr>
      <td>cumprod()</td>
      <td>Column prefix-prod (For row-prefix prod, use cumprod(t(X))</td>
      <td>Input: matrix <br /> Output: matrix of the same dimensions</td>
      <td>A = matrix(&#8220;1 2 3 4 5 6&#8221;, rows=3, cols=2) <br /> B = cumprod(A) <br /> The output matrix B = [[1, 2], [3, 8], [15, 48]]</td>
    </tr>
    <tr>
      <td>cummin()</td>
      <td>Column prefix-min (For row-prefix min, use cummin(t(X))</td>
      <td>Input: matrix <br /> Output: matrix of the same dimensions</td>
      <td>A = matrix(&#8220;3 4 1 6 5 2&#8221;, rows=3, cols=2) <br /> B = cummin(A) <br /> The output matrix B = [[3, 4], [1, 4], [1, 2]]</td>
    </tr>
    <tr>
      <td>cummax()</td>
      <td>Column prefix-max (For row-prefix min, use cummax(t(X))</td>
      <td>Input: matrix <br /> Output: matrix of the same dimensions</td>
      <td>A = matrix(&#8220;3 4 1 6 5 2&#8221;, rows=3, cols=2) <br /> B = cummax(A) <br /> The output matrix B = [[3, 4], [3, 6], [5, 6]]</td>
    </tr>
    <tr>
      <td>sample(range, size, replacement, seed)</td>
      <td>Sample returns a column vector of length size, containing uniform random numbers from [1, range]</td>
      <td>Input: <br /> range: integer <br /> size: integer <br /> replacement: boolean (Optional, default: FALSE) <br /> seed: integer (Optional) <br /> Output: Matrix dimensions are size x 1</td>
      <td>sample(100, 5) <br /> sample(100, 5, TRUE) <br /> sample(100, 120, TRUE) <br /> sample(100, 5, 1234) # 1234 is the seed <br /> sample(100, 5, TRUE, 1234)</td>
    </tr>
    <tr>
      <td>outer(vector1, vector2, &#8220;op&#8221;)</td>
      <td>Applies element wise binary operation &#8220;op&#8221; (for example: &#8220;&lt;&#8221;, &#8220;==&#8221;, &#8220;&gt;=&#8221;, &#8220;<em>&#8221;, &#8220;min&#8221;) on the all combination of vector. <br /> Note: Using &#8220;</em>&#8221;, we get outer product of two vectors.</td>
      <td>Input: vectors of same size d, string <br /> Output: matrix of size d X d</td>
      <td>A = matrix(&#8220;1 4&#8221;, rows = 2, cols = 1) <br /> B = matrix(&#8220;3 6&#8221;, rows = 1, cols = 2) <br /> C = outer(A, B, &#8220;&lt;&#8221;) <br /> D = outer(A, B, &#8220;*&#8221;) <br /> The output matrix C = [[1, 1], [0, 1]] <br /> The output matrix D = [[3, 6], [12, 24]]<br /></td>
    </tr>
    <tr>
      <td>toOneHot(X, num_classes)</td>
      <td>Converts a vector containing integers to a one-hot-encoded matrix</td>
      <td>Input: vector with N integer entries between 1 and num_classes, number of columns (must be &gt;= largest value in X)<br />Output: one-hot-encoded matrix with shape (N, num_classes)</td>
      <td>X = round(rand(rows=10, cols=1, min=2, max=10)); <br />num_classes = ​12; <br />Y = toOneHot(X, num_classes);</td>
    </tr>
  </tbody>
</table>

<h4 id="alternative-forms-of-table">Alternative forms of table()</h4>

<p>The built-in function table() supports different types of input parameters. These variations are described below:</p>

<ul>
  <li>Basic form: <code class="language-plaintext highlighter-rouge">F=table(A,B)</code>
As described above in Table 7.</li>
  <li>Weighted form: <code class="language-plaintext highlighter-rouge">F=table(A,B,W)</code>
Users can provide an optional third parameter C with the same dimensions as of A and B. In this case, the output F[i,j] = ∑kC[k], where A[k] = i and B[k] = j (1 ≤ k ≤ n).</li>
  <li>Scalar form
In basic and weighted forms, both B and W are one dimensional matrices with same number of rows/columns as in A. Instead, one can also pass-in scalar values in the place of B and W. For example, F=table(A,1) is same as the basic form where B is a matrix with all 1’s. Similarly, <code class="language-plaintext highlighter-rouge">F=table(A,B,3)</code> is identical to the following two DML statements. <br />
<code class="language-plaintext highlighter-rouge">m3 = matrix(3,rows=nrow(A),cols=1); </code> <br />
<code class="language-plaintext highlighter-rouge">F = table(A,B,m3);</code></li>
  <li>Specified Output Size
In the above forms, the dimensions of the matrix produced this function is known only after its execution is complete. Users can precisely control the size of the output matrix via two additional arguments, odim1 and odim2, as shown below: <br />
<code class="language-plaintext highlighter-rouge">F = table(A,B,odim1,odim2);</code> <br />
The output F will have exactly <code class="language-plaintext highlighter-rouge">odim1</code> rows and <code class="language-plaintext highlighter-rouge">odim2</code> columns. F may be a truncated or padded (with zeros) version of the output produced by <code class="language-plaintext highlighter-rouge">table(A,B)</code> &#8211; depending on the values of <code class="language-plaintext highlighter-rouge">max(A)</code> and <code class="language-plaintext highlighter-rouge">max(B)</code>. For example, if <code class="language-plaintext highlighter-rouge">max(A) &lt; odim1</code> then the last (<code class="language-plaintext highlighter-rouge">odim1-max(A)</code>) rows will have zeros.</li>
</ul>

<h4 id="alternative-forms-of-aggregate">Alternative forms of aggregate()</h4>

<p>The built-in function aggregate() supports different types of input parameters. These variations are described below:</p>

<ul>
  <li>Basic form: <code class="language-plaintext highlighter-rouge">F=aggregate(target=X, groups=G, fn="sum")</code>
As described above in Table 7.</li>
  <li>Weighted form: <code class="language-plaintext highlighter-rouge">F=aggregate(target=X, groups=G, weights=W, fn="sum")</code>
Users can provide an optional parameter W with the same dimensions as of A and B. In this case, fn computes the weighted statistics over values from X, which are grouped by values from G.</li>
  <li>Specified Output Size
As noted in Table 7, the number of rows in the output matrix F is equal to the maximum value in the grouping matrix G. Therefore, the dimensions of F are known only after its execution is complete. When needed, users can precisely control the size of the output matrix via an additional argument, <code class="language-plaintext highlighter-rouge">ngroups</code>, as shown below: <br />
<code class="language-plaintext highlighter-rouge">F = aggregate(target=X, groups=G, fn="sum", ngroups=10);</code> <br />
The output F will have exactly 10 rows and 1 column. F may be a truncated or padded (with zeros) version of the output produced by <code class="language-plaintext highlighter-rouge">aggregate(target=X, groups=G, fn="sum")</code> – depending on the values of <code class="language-plaintext highlighter-rouge">ngroups</code> and <code class="language-plaintext highlighter-rouge">max(G)</code>. For example, if <code class="language-plaintext highlighter-rouge">max(G) &lt; ngroups</code> then the last (<code class="language-plaintext highlighter-rouge">ngroups-max(G)</code>) rows will have zeros.</li>
</ul>

<h4 id="probability-distribution-functions">Probability Distribution Functions</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`p = cdf(target=q, dist=fn, ..., lower.tail=TRUE)`
</code></pre></div></div>

<p>This computes the cumulative probability at the given quantile i.e., P[X&lt;=q], where X is random variable whose distribution is specified via string argument fn.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">target</code>: input quantile at which cumulative probability P[X&lt;=q] is computed, where X is random variable whose distribution is specified via string argument fn. This is a mandatory argument.</li>
  <li><code class="language-plaintext highlighter-rouge">dist</code>: name of the distribution specified as a string. Valid values are &#8220;normal&#8221; (for Normal or Gaussian distribution), &#8220;f&#8221; (for F distribution), &#8220;t&#8221; (for Student t-distribution), &#8220;chisq&#8221; (for Chi Squared distribution), and &#8220;exp&#8221; (for Exponential distribution). This is a mandatory argument.</li>
  <li><code class="language-plaintext highlighter-rouge">...</code>: parameters of the distribution
    <ul>
      <li>For <code class="language-plaintext highlighter-rouge">dist="normal"</code>, valid parameters are mean and sd that specify the mean and standard deviation of the normal distribution. The default values for mean and sd are 0.0 and 1.0, respectively.</li>
      <li>For <code class="language-plaintext highlighter-rouge">dist="f"</code>, valid parameters are df1 and df2 that specify two degrees of freedom. Both these parameters are mandatory.</li>
      <li>For <code class="language-plaintext highlighter-rouge">dist="t"</code>, and dist=&#8221;chisq&#8221;, valid parameter is df that specifies the degrees of freedom. This parameter is mandatory.</li>
      <li>For <code class="language-plaintext highlighter-rouge">dist="exp"</code>, valid parameter is rate that specifies the rate at which events occur. Note that the mean of exponential distribution is 1.0/rate. The default value is 1.0.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Lower.tail</code>: a Boolean value with default set to TRUE. cdf() computes P[X&lt;=q] when lower.tail=TRUE and it computes P[X&gt;q] when lower.tail=FALSE. In other words, a complement of the cumulative distribution is computed when lower.tail=FALSE.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>`q = icdf(target=p, dist=fn, ...)`
</code></pre></div></div>

<p>This computes the inverse cumulative probability i.e., it computes a quantile q such that the given probability p = P[X&lt;=q], where X is random variable whose distribution is specified via string argument fn.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">target</code>: a mandatory argument that specifies the input probability.</li>
  <li><code class="language-plaintext highlighter-rouge">dist</code>: name of the distribution specified as a string. Same as that in cdf().</li>
  <li><code class="language-plaintext highlighter-rouge">...</code>: parameters of the distribution. Same as those in cdf().</li>
</ul>

<p>Alternative to <code class="language-plaintext highlighter-rouge">cdf()</code> and <code class="language-plaintext highlighter-rouge">icdf()</code>, users can also use distribution-specific functions. The functions <code class="language-plaintext highlighter-rouge">pnorm()</code>, <code class="language-plaintext highlighter-rouge">pf()</code>, <code class="language-plaintext highlighter-rouge">pt()</code>, <code class="language-plaintext highlighter-rouge">pchisq()</code>, and <code class="language-plaintext highlighter-rouge">pexp()</code> computes the cumulative probabilities for Normal, F, t, Chi Squared, and Exponential distributions, respectively. Appropriate distribution parameters must be provided for each function. Similarly, <code class="language-plaintext highlighter-rouge">qnorm()</code>, <code class="language-plaintext highlighter-rouge">qf()</code>, <code class="language-plaintext highlighter-rouge">qt()</code>, <code class="language-plaintext highlighter-rouge">qchisq()</code>, and <code class="language-plaintext highlighter-rouge">qexp()</code> compute the inverse cumulative probabilities for Normal, F, t, Chi Squared, and Exponential distributions.</p>

<p>Following pairs of DML statements are equivalent.</p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="normal", mean=1.5, sd=2);</code>
is same as
<code class="language-plaintext highlighter-rouge">p=pnorm(target=q, mean=1.5, sd=2);</code></p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="exp", rate=5);</code>
is same as
<code class="language-plaintext highlighter-rouge">pexp(target=q,rate=5);</code></p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="chisq", df=100);</code>
is same as
<code class="language-plaintext highlighter-rouge">pchisq(target=q, df=100)</code></p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="f", df1=100, df2=200);</code>
is same as
<code class="language-plaintext highlighter-rouge">pf(target=q, df1=100, df2=200);</code></p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="t", df=100);</code>
is same as
<code class="language-plaintext highlighter-rouge">pt(target=q, df=100)</code></p>

<p><code class="language-plaintext highlighter-rouge">p = cdf(target=q, dist="normal", lower.tail=FALSE);</code>
is same as
<code class="language-plaintext highlighter-rouge">p=pnorm(target=q, lower.tail=FALSE);</code>
is same as
<code class="language-plaintext highlighter-rouge">p=pnorm(target=q, mean=0, sd=1.0, lower.tail=FALSE);</code>
is same as
<code class="language-plaintext highlighter-rouge">p=pnorm(target=q, sd=1.0, lower.tail=FALSE);</code></p>

<p>Examples of icdf():</p>

<p><code class="language-plaintext highlighter-rouge">q=icdf(target=p, dist="normal");</code>
is same as
<code class="language-plaintext highlighter-rouge">q=qnorm(target=p, mean=0,sd=1);</code></p>

<p><code class="language-plaintext highlighter-rouge">q=icdf(target=p, dist="exp");</code>
is same as
<code class="language-plaintext highlighter-rouge">q=qexp(target=p, rate=1);</code></p>

<p><code class="language-plaintext highlighter-rouge">q=icdf(target=p, dist="chisq", df=50);</code>
is same as
<code class="language-plaintext highlighter-rouge">qchisq(target=p, df=50);</code></p>

<p><code class="language-plaintext highlighter-rouge">q=icdf(target=p, dist="f", df1=50, df2=25);</code>
is same as
<code class="language-plaintext highlighter-rouge">qf(target=p, , df1=50, df2=25);</code></p>

<p><code class="language-plaintext highlighter-rouge">q=icdf(target=p, dist="t", df=50);</code>
is same as
<code class="language-plaintext highlighter-rouge">qt(target=p, df=50);</code></p>

<h3 id="mathematical-and-trigonometric-built-in-functions">Mathematical and Trigonometric Built-In Functions</h3>

<p><strong>Table 8</strong>: Mathematical and Trigonometric Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>exp(), log(), abs(), sqrt(), round(), floor(), ceil(), ceiling()</td>
      <td>Apply mathematical function on input (cell wise if input is matrix)</td>
      <td>Input: (&lt;matrix&gt;), or (&lt;scalar&gt;) <br /> Output: &lt;matrix&gt;, or &lt;scalar&gt;</td>
      <td>sqrt(X) <br /> log(X,y) <br /> round(X) <br /> floor(X) <br /> ceil(X) <br /> ceiling(X)</td>
    </tr>
    <tr>
      <td>sin(), cos(), tan(), sinh(), cosh(), tanh(), asin(), acos(), atan()</td>
      <td>Apply trigonometric function on input (cell wise if input is matrix)</td>
      <td>Input: (&lt;matrix&gt;), or (&lt;scalar&gt;) <br /> Output: &lt;matrix&gt;, or &lt;scalar&gt;</td>
      <td>sin(X)</td>
    </tr>
    <tr>
      <td>sign()</td>
      <td>Returns a matrix representing the signs of the input matrix elements, where 1 represents positive, 0 represents zero, and -1 represents negative</td>
      <td>Input : (A &lt;matrix&gt;) <br /> Output : &lt;matrix&gt;</td>
      <td><span style="white-space: nowrap;">A = matrix(&#8220;-5 0 3 -3&#8221;,</span> rows=2, cols=2) <br />signA = sign(A)<br />Matrix signA: [[-1, 0], [1, -1]]</td>
    </tr>
  </tbody>
</table>

<h3 id="linear-algebra-built-in-functions">Linear Algebra Built-In Functions</h3>

<p><strong>Table 9</strong>: Linear Algebra Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cholesky()</td>
      <td>Computes the Cholesky decomposition of symmetric input matrix A</td>
      <td>Input: (A &lt;matrix&gt;) <br /> Output: &lt;matrix&gt;</td>
      <td><span style="white-space: nowrap;">A = matrix(&#8220;4 12 -16 12 37 -43</span> -16 -43 98&#8221;, rows=3, cols=3) <br /> B = cholesky(A)<br /> Matrix B: [[2, 0, 0], [6, 1, 0], [-8, 5, 3]]</td>
    </tr>
    <tr>
      <td>diag()</td>
      <td>Create diagonal matrix from (n x 1) matrix, or take diagonal from square matrix</td>
      <td>Input: (n x 1) matrix, or (n x n) matrix <br /> Output: (n x n) matrix, or (n x 1) matrix</td>
      <td>D = diag(matrix(1.0, rows=3, cols=1))<br /> E = diag(matrix(1.0, rows=3, cols=3))</td>
    </tr>
    <tr>
      <td>eigen()</td>
      <td>Computes Eigen decomposition of input matrix A. The Eigen decomposition consists of two matrices V and w such that A = V %*% diag(w) %*% t(V). The columns of V are the eigenvectors of the original matrix A. And, the eigen values are given by w. <br /> It is important to note that this function can operate only on small-to-medium sized input matrix that can fit in the main memory. For larger matrices, an out-of-memory exception is raised.</td>
      <td>Input : (A &lt;matrix&gt;) <br /> Output : [w &lt;(m x 1) matrix&gt;, V &lt;matrix&gt;] <br /> A is a square symmetric matrix with dimensions (m x m). This function returns two matrices w and V, where w is (m x 1) and V is of size (m x m).</td>
      <td>[w, V] = eigen(A)</td>
    </tr>
    <tr>
      <td>inv()</td>
      <td>Computes the inverse of a squared matrix. Alternative name: inverse()</td>
      <td>Input:  &lt;matrix&gt;<br /> Output: &lt;matrix&gt;</td>
      <td>B = inv(A)</td>
    </tr>
    <tr>
      <td>lu()</td>
      <td>Computes Pivoted LU decomposition of input matrix A. The LU decomposition consists of three matrices P, L, and U such that P %*% A = L %*% U, where P is a permutation matrix that is used to rearrange the rows in A before the decomposition can be computed. L is a lower-triangular matrix whereas U is an upper-triangular matrix. <br /> It is important to note that this function can operate only on small-to-medium sized input matrix that can fit in the main memory. For larger matrices, an out-of-memory exception is raised.</td>
      <td>Input : (A &lt;matrix&gt;) <br /> Output : [&lt;matrix&gt;, &lt;matrix&gt;, &lt;matrix&gt;] <br /> A is a square matrix with dimensions m x m. This function returns three matrices P, L, and U, all of which are of size m x m.</td>
      <td>[P, L, U] = lu(A)</td>
    </tr>
    <tr>
      <td>qr()</td>
      <td>Computes QR decomposition of input matrix A using Householder reflectors. The QR decomposition of A consists of two matrices Q and R such that A = Q%*%R where Q is an orthogonal matrix (i.e., Q%*%t(Q) = t(Q)%*%Q = I, identity matrix) and R is an upper triangular matrix. For efficiency purposes, this function returns the matrix of Householder reflector vectors H instead of Q (which is a large m x m potentially dense matrix). The Q matrix can be explicitly computed from H, if needed. In most applications of QR, one is interested in calculating Q %*% B or t(Q) %*% B – and, both can be computed directly using H instead of explicitly constructing the large Q matrix. <br /> It is important to note that this function can operate only on small-to-medium sized input matrix that can fit in the main memory. For larger matrices, an out-of-memory exception is raised.</td>
      <td>Input : (A &lt;matrix&gt;) <br /> Output : [&lt;matrix&gt;, &lt;matrix&gt;] <br /> A is a (m x n) matrix, which can either be a square matrix (m=n) or a rectangular matrix (m != n). This function returns two matrices H and R of size (m x n) i.e., same size as of the input matrix A.</td>
      <td>[H, R] = qr(A)</td>
    </tr>
    <tr>
      <td>solve()</td>
      <td>Computes the least squares solution for system of linear equations A %*% x = b i.e., it finds x such that ||A%*%x – b|| is minimized. The solution vector x is computed using a QR decomposition of A. <br /> It is important to note that this function can operate only on small-to-medium sized input matrix that can fit in the main memory. For larger matrices, an out-of-memory exception is raised.</td>
      <td>Input : (A &lt;(m x n) matrix&gt;, b &lt;(m x 1) matrix&gt;) <br /> Output : &lt;matrix&gt; <br /> A is a matrix of size (m x n) and b is a 1D matrix of size m x 1. This function returns a 1D matrix x of size n x 1.</td>
      <td>x = solve(A,b)</td>
    </tr>
    <tr>
      <td>svd()</td>
      <td>Singular Value Decomposition of a matrix A (of size m x m), which decomposes into three matrices U, V, and S as A = U %<em>% S %</em>% t(V), where U is an m x m unitary matrix (i.e., orthogonal), V is an n x n unitary matrix (also orthogonal), and S is an m x n matrix with non-negative real numbers on the diagonal.</td>
      <td>Input: matrix A &lt;(m x n)&gt; <br /> Output: matrices U &lt;(m x m)&gt;, S &lt;(m x n)&gt;, and V &lt;(n x n)&gt;</td>
      <td>[U, S, V] = svd(A)</td>
    </tr>
    <tr>
      <td>t()</td>
      <td>Transpose matrix</td>
      <td>Input: matrix <br /> Output: matrix</td>
      <td>t(X)</td>
    </tr>
    <tr>
      <td>trace()</td>
      <td>Return the sum of the cells of the main diagonal square matrix</td>
      <td>Input: matrix <br /> Output: scalar</td>
      <td>trace(X)</td>
    </tr>
  </tbody>
</table>

<h3 id="readwrite-built-in-functions">Read/Write Built-In Functions</h3>

<p>The <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> functions support the reading and writing of matrices and scalars from/to the file system
(local or HDFS). Typically, associated with each data file is a JSON-formatted metadata file (MTD) that stores
metadata information about the content of the data file, such as the number of rows and columns.
For data files written by SystemDS, an MTD file will automatically be generated. The name of the
MTD file associated with <code class="language-plaintext highlighter-rouge">&lt;filename&gt;</code> must be <code class="language-plaintext highlighter-rouge">&lt;filename.mtd&gt;</code>. In general, it is highly recommended
that users provide MTD files for their own data as well.</p>

<p><em>Note: Metadata can also be passed as parameters to <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> function calls.</em></p>

<h4 id="file-formats-and-mtd-files">File formats and MTD files</h4>

<p>SystemDS supports 6 file formats:</p>

<ul>
  <li>CSV (delimited)</li>
  <li>Matrix Market (coordinate)</li>
  <li>Text (i,j,v)</li>
  <li>LIBSVM</li>
  <li>Binary</li>
  <li>HDF5</li>
  <li>COG</li>
</ul>

<p>The CSV format is a standard text-based format where columns are separated by delimiter characters, typically commas, and
rows are represented on separate lines.</p>

<p>SystemDS supports the Matrix Market coordinate format, which is a text-based, space-separated format used to
represent sparse matrices. Additional information about the Matrix Market format can be found at
<a href="http://math.nist.gov/MatrixMarket/formats.html#MMformat">http://math.nist.gov/MatrixMarket/formats.html#MMformat</a>.
SystemDS does not currently support the Matrix Market array format for dense matrices. In the Matrix Market
coordinate format, metadata (the number of rows, the number of columns, and the number of non-zero values) are
included in the data file. Rows and columns index from 1. Matrix Market data must be in a single file, whereas the
(i,j,v) text format can span multiple part files on HDFS. Therefore, for scalability reasons, the use of the (i,j,v) text and
binary formats is encouraged when scaling to big data.</p>

<p>The (i,j,v) format is a text-based sparse format in which the cell values of a matrix are serialized in space-separated triplets
of rowId, columnId, and cellValue, with the rowId and columnId indices being 1-based. This is similar to the Matrix Market
coordinate format, except metadata is stored in a separate file rather than in the data file itself, and the (i,j,v) text format
can span multiple part files.</p>

<p>The binary format can only be read and written by SystemDS.</p>

<p>Hierarchical Data Format (HDF) is a file format designed to store and organize large amounts of data. SystemDS supports 
some features of the HDF5 like two dimension data (Matrix), matrix with FP64 (double) data type, 
single dataset, single group, and contiguous dataset.</p>

<p>Cloud Optimized GeoTIFF (COG) is an image format designed to store large amounts of geospatial data while allowing for
efficient access. This is done by splitting the image into tiles which can then be accessed independently. Currently, SystemDS
only supports reading COG files and can only process the most important metadata that is required for reading the image. Normal
TIFF files that aren&#8217;t tiled cannot be read by SystemDS. Support for BigTIFF is very limited and not recommended.</p>

<p>The currently supported compression methods are as follows:</p>
<ul>
  <li>None</li>
  <li>Deflate</li>
</ul>

<p>Let&#8217;s look at a matrix and examples of its data represented in the supported formats with corresponding metadata. In the table below, we have
a matrix consisting of 4 rows and 3 columns.</p>

<p><strong>Table 10</strong>: Matrix</p>

<table>
	<tr>
	  <td class="centerboldcell">1.0</td>
	  <td class="centerboldcell">2.0</td>
	  <td class="centerboldcell">3.0</td>
	</tr>
	<tr>
	  <td class="centerboldcell">0</td>
	  <td class="centerboldcell">0</td>
	  <td class="centerboldcell">0</td>
	</tr>
	<tr>
	  <td class="centerboldcell">7.0</td>
	  <td class="centerboldcell">8.0</td>
	  <td class="centerboldcell">9.0</td>
	</tr>
	<tr>
	  <td class="centerboldcell">0</td>
	  <td class="centerboldcell">0</td>
	  <td class="centerboldcell">0</td>
	</tr>
</table>

<p>Below, we have examples of this matrix in the CSV, Matrix Market, IJV, and Binary formats, along with corresponding metadata.</p>

<div class="codetabs2">

<div data-lang="CSV">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0,2.0,3.0
0,0,0
7.0,8.0,9.0
0,0,0
</code></pre></div>    </div>
  </div>

<div data-lang="CSV MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 4,
    "cols": 3,
    "nnz": 6,
    "format": "csv",
    "header": false,
    "sep": ",",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div>    </div>
  </div>

<div data-lang="Matrix Market">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%%MatrixMarket matrix coordinate real general
4 3 6
1 1 1.0
1 2 2.0
1 3 3.0
3 1 7.0
3 2 8.0
3 3 9.0
</code></pre></div>    </div>
  </div>

<div data-lang="IJV">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 1 1.0
1 2 2.0
1 3 3.0
3 1 7.0
3 2 8.0
3 3 9.0
</code></pre></div>    </div>
  </div>

<div data-lang="IJV MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 4,
    "cols": 3,
    "nnz": 6,
    "format": "text",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div>    </div>
  </div>

<div data-lang="Binary">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Binary is not a text-based format.
</code></pre></div>    </div>
  </div>

<div data-lang="Binary MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 4,
    "cols": 3,
    "rows_in_block": 1000,
    "cols_in_block": 1000,
    "nnz": 6,
    "format": "binary",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div>    </div>
  </div>

<div data-lang="HDF5">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HDF5 is not a text-based format.
</code></pre></div>    </div>
  </div>

<div data-lang="HDF5 MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 4,
    "cols": 3,
    "nnz": 6,
    "dataset": "systemds",
    "format": "hdf5",
    "author": "SystemDS",
    "created": "2021-06-11 13:36:15 CET"
}
</code></pre></div>    </div>
  </div>

</div>

<p>As another example, here we see the content of the MTD file <code class="language-plaintext highlighter-rouge">scalar.mtd</code> associated with a scalar data file <code class="language-plaintext highlighter-rouge">scalar</code>
that contains the scalar value 2.0.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "scalar",
    "value_type": "double",
    "format": "text",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<p>Metadata is represented as an MTD file that contains a single JSON object with the attributes described below.</p>

<p><strong>Table 11</strong>: MTD attributes</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Description</th>
      <th>Optional</th>
      <th>Permissible values</th>
      <th>Data type valid for</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">data_type</code></td>
      <td>Indicates the data type of the data</td>
      <td>Yes. Default value is <code class="language-plaintext highlighter-rouge">matrix</code> if not specified</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">value_type</code></td>
      <td>Indicates the value type of the data</td>
      <td>Yes. Default value is <code class="language-plaintext highlighter-rouge">double</code> if not specified</td>
      <td><code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">boolean</code>. Must be <code class="language-plaintext highlighter-rouge">double</code> when <code class="language-plaintext highlighter-rouge">data_type</code> is <code class="language-plaintext highlighter-rouge">matrix</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rows</code></td>
      <td>Number of rows in <code class="language-plaintext highlighter-rouge">matrix</code></td>
      <td>Yes – only when <code class="language-plaintext highlighter-rouge">format</code> is <code class="language-plaintext highlighter-rouge">csv</code></td>
      <td>any integer &gt; <code class="language-plaintext highlighter-rouge">0</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cols</code></td>
      <td>Number of columns in <code class="language-plaintext highlighter-rouge">matrix</code></td>
      <td>Yes – only when <code class="language-plaintext highlighter-rouge">format</code> is <code class="language-plaintext highlighter-rouge">csv</code></td>
      <td>any integer &gt; <code class="language-plaintext highlighter-rouge">0</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">rows_in_block</code>, <code class="language-plaintext highlighter-rouge">cols_in_block</code></td>
      <td>Valid only for <code class="language-plaintext highlighter-rouge">binary</code> format. Indicates dimensions of blocks</td>
      <td>No. Only valid if <code class="language-plaintext highlighter-rouge">matrix</code> is in <code class="language-plaintext highlighter-rouge">binary</code> format</td>
      <td>any integer &gt; <code class="language-plaintext highlighter-rouge">0</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code> in <code class="language-plaintext highlighter-rouge">binary</code> format. Valid only when <code class="language-plaintext highlighter-rouge">binary</code> format</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">nnz</code></td>
      <td>Number of non-zero values</td>
      <td>Yes</td>
      <td>any integer &gt; <code class="language-plaintext highlighter-rouge">0</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">format</code></td>
      <td>Data file format</td>
      <td>Yes. Default value is <code class="language-plaintext highlighter-rouge">text</code></td>
      <td><code class="language-plaintext highlighter-rouge">csv</code>, <code class="language-plaintext highlighter-rouge">mm</code>, <code class="language-plaintext highlighter-rouge">text</code>, <code class="language-plaintext highlighter-rouge">binary</code></td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar</code>. Formats <code class="language-plaintext highlighter-rouge">csv</code> and <code class="language-plaintext highlighter-rouge">mm</code> are applicable only to matrices</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">description</code></td>
      <td>Description of the data</td>
      <td>Yes</td>
      <td>Any valid JSON string or object</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code>, <code class="language-plaintext highlighter-rouge">scalar</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">author</code></td>
      <td>User that created the metadata file, defaults to <code class="language-plaintext highlighter-rouge">SystemDS</code></td>
      <td>N/A</td>
      <td>N/A</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">created</code></td>
      <td>Date/time when metadata file was written</td>
      <td>N/A</td>
      <td>N/A</td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>

<p>In addition, when reading or writing CSV files, the metadata may contain one or more of the following five attributes.
Note that this metadata can be specified as parameters to the <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> function calls.</p>

<p><strong>Table 12</strong>: Additional MTD attributes when reading/writing CSV files</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Description</th>
      <th>Optional</th>
      <th>Permissible values</th>
      <th>Data type valid for</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">header</code></td>
      <td>Specifies whether the data file has a header. If the header exists, it must be the first line in the file.</td>
      <td>Yes, default value is <code class="language-plaintext highlighter-rouge">false</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code> (<code class="language-plaintext highlighter-rouge">TRUE</code>/<code class="language-plaintext highlighter-rouge">FALSE</code> in DML)</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sep</code></td>
      <td>Specifies the separator (delimiter) used in the data file. Note that using a delimiter composed of just numeric values or a period (decimal point) can be ambiguous and may lead to unexpected results.</td>
      <td>Yes, default value is &#8220;<code class="language-plaintext highlighter-rouge">,</code>&#8221; (comma)</td>
      <td>string</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fill</code></td>
      <td>Only valid when reading CSV files. It specifies whether or not to fill the empty fields in the input file. Empty fields are denoted by consecutive separators (delimiters). If <code class="language-plaintext highlighter-rouge">fill</code> is <code class="language-plaintext highlighter-rouge">true</code> then every empty field is filled with the value specified by the &#8220;default&#8221; attribute. An exception is raised if <code class="language-plaintext highlighter-rouge">fill</code> is <code class="language-plaintext highlighter-rouge">false</code> and the input file has one or more empty fields.</td>
      <td>Yes, default is <code class="language-plaintext highlighter-rouge">true</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">true</code>/<code class="language-plaintext highlighter-rouge">false</code> (<code class="language-plaintext highlighter-rouge">TRUE</code>/<code class="language-plaintext highlighter-rouge">FALSE</code> in DML)</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">default</code></td>
      <td>Only valid when reading CSV files and <code class="language-plaintext highlighter-rouge">fill</code> is <code class="language-plaintext highlighter-rouge">true</code>. It specifies the special value with which all empty values are filled while reading the input matrix.</td>
      <td>Yes, default value is <code class="language-plaintext highlighter-rouge">0</code></td>
      <td>any double</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sparse</code></td>
      <td>Only valid when writing CSV files. It specifies whether or not to explicitly output zero (<code class="language-plaintext highlighter-rouge">0</code>) values. Zero values are written out only when <code class="language-plaintext highlighter-rouge">sparse=FALSE</code>.</td>
      <td>Yes, default value is <code class="language-plaintext highlighter-rouge">FALSE</code>.</td>
      <td><code class="language-plaintext highlighter-rouge">TRUE</code>/<code class="language-plaintext highlighter-rouge">FALSE</code> in DML</td>
      <td><code class="language-plaintext highlighter-rouge">matrix</code></td>
    </tr>
  </tbody>
</table>

<p>Furthermore, the following additional notes apply when reading and writing CSV files.</p>

<ul>
  <li>Every line in the input file must have the same number of fields or values.</li>
  <li>The input file can only contain numeric values separated by the delimiter (as specified by <code class="language-plaintext highlighter-rouge">sep</code>).</li>
  <li>While writing CSV files, if <code class="language-plaintext highlighter-rouge">header=TRUE</code> is specified as a parameter to the <code class="language-plaintext highlighter-rouge">write</code> function, then the header line is formed as a concatenated string of column names separated by delimiters. Columns are of the form <code class="language-plaintext highlighter-rouge">C&lt;column_id&gt;</code>. For a matrix with 5 columns, the header line would look like: <code class="language-plaintext highlighter-rouge">C1,C2,C3,C4,C5</code> (assuming <code class="language-plaintext highlighter-rouge">sep=","</code>).</li>
</ul>

<h4 id="read-built-in-function">Read Built-In Function</h4>

<p>The syntax of the <code class="language-plaintext highlighter-rouge">read</code> statement is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read("inputfile", [additional parameters])
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">"inputfile"</code> (also known as <code class="language-plaintext highlighter-rouge">iofilename</code>) is the path to the data file in the file system. The list of parameters is the same as the metadata attributes
provided in MTD files. For the <code class="language-plaintext highlighter-rouge">"inputfile"</code> parameter, the user can use constant string concatenation to give the full path of the
file, where &#8220;+&#8221; is used as the concatenation operator. However, the file path must evaluate to a constant string at compile time. For
example, <code class="language-plaintext highlighter-rouge">"/my/dir" + "filename.mtx"</code> is valid parameter but <code class="language-plaintext highlighter-rouge">"/my/dir" + "filename" + i + ".mtx"</code> is not (where <code class="language-plaintext highlighter-rouge">i</code> is a variable).</p>

<p>The user has the option of specifying each parameter value in the MTD file, the <code class="language-plaintext highlighter-rouge">read</code> function invocation, or in both locations.
<strong>However, parameter values specified in both the <code class="language-plaintext highlighter-rouge">read</code> invocation and the MTD file must have the same value. Also, if a scalar value is being read,
then <code class="language-plaintext highlighter-rouge">format</code> cannot be specified.</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">read</code> invocation in SystemDS is parameterized as follows during compilation.</p>

<ol>
  <li>Default values are assigned to parameters.</li>
  <li>Parameters provided in <code class="language-plaintext highlighter-rouge">read()</code> either fill in values or override defaults.</li>
  <li>SystemDS will look for the MTD file at compile time in the specified location (at the same path as the data file, where the filename of the MTD file is the same name as the data file with the extension <code class="language-plaintext highlighter-rouge">.mtd</code>).</li>
  <li>If all non-optional parameters aren&#8217;t specified or conflicting values are detected, then an exception is thrown.</li>
</ol>

<h5 id="examples-8"><strong>Examples</strong></h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Read a matrix with path "in/v.ijv".
# Defaults for data_type and value_type are used.
V = read("in/v.ijv", rows=10, cols=8, format="text");

# Read a matrix with path "in/v.ijv".
# The user specifies "in/" as the directory and "v" as
# the file name and uses constant string concatenation.
dir = "in/";
file = "v.ijv";
V = read(dir + file, rows=10, cols=8, format="text");

# Read a matrix data file with an MTD file available
# (MTD file path: in/data.ijv.mtd)
V = read("in/data.ijv");

# Read a csv matrix data file with no header, comma as
# separator, 3 rows, and 3 columns.
V = read("m.csv", format="csv", header=FALSE, sep=",", rows=3, cols=3);

# Read a csv matrix data file with an MTD file available
# (MTD file: m.csv.mtd)
V = read("m.csv");

# Read a scalar integer value from file "in/scalar"
V = read("in/scalar", data_type="scalar", value_type="int");
</code></pre></div></div>

<p>Additionally, <code class="language-plaintext highlighter-rouge">readMM()</code> and <code class="language-plaintext highlighter-rouge">read.csv()</code> are supported and can be used instead of specifying <code class="language-plaintext highlighter-rouge">format="mm"</code> or <code class="language-plaintext highlighter-rouge">format="csv"</code> in the <code class="language-plaintext highlighter-rouge">read()</code> function.</p>

<h4 id="write-built-in-function">Write Built-In Function</h4>

<p>The <code class="language-plaintext highlighter-rouge">write</code> method is used to persist <code class="language-plaintext highlighter-rouge">scalar</code> and <code class="language-plaintext highlighter-rouge">matrix</code> data to files in the local file system or HDFS. The syntax of <code class="language-plaintext highlighter-rouge">write</code> is shown below.
The parameters are described in Table 13. Note that the set of supported parameters for <code class="language-plaintext highlighter-rouge">write</code> is NOT the same as for <code class="language-plaintext highlighter-rouge">read</code>.
SystemDS writes an MTD file for the written data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write(identifier, "outputfile", [additional parameters])
</code></pre></div></div>

<p>The user can use constant string concatenation in the <code class="language-plaintext highlighter-rouge">"outputfile"</code> parameter to give the full path of the file, where <code class="language-plaintext highlighter-rouge">+</code> is used as the concatenation operator.</p>

<p><strong>Table 13</strong>: Parameters for <code class="language-plaintext highlighter-rouge">write()</code> method</p>

<table>
  <thead>
    <tr>
      <th>Parameter Name</th>
      <th>Description</th>
      <th>Optional</th>
      <th>Permissible Values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">identifier</code></td>
      <td>Variable whose data is to be written to a file. Data can be <code class="language-plaintext highlighter-rouge">matrix</code> or <code class="language-plaintext highlighter-rouge">scalar</code>.</td>
      <td>No</td>
      <td>Any variable name</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">"outputfile"</code></td>
      <td>The path to the data file in the file system</td>
      <td>No</td>
      <td>Any valid filename</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[additional parameters]</code></td>
      <td>See Tables 11 and 12</td>
      <td>&#160;</td>
      <td>&#160;</td>
    </tr>
  </tbody>
</table>

<h5 id="examples-9"><strong>Examples</strong></h5>

<p>Write <code class="language-plaintext highlighter-rouge">V</code> matrix to file <code class="language-plaintext highlighter-rouge">out/file.ijv</code> in the default <code class="language-plaintext highlighter-rouge">text</code> format. This also creates the metadata file <code class="language-plaintext highlighter-rouge">out/file.ijv.mtd</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write(V, "out/file.ijv");
</code></pre></div></div>

<p>Example content of <code class="language-plaintext highlighter-rouge">out/file.ijv.mtd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 10,
    "cols": 8,
    "nnz": 4,
    "format": "text",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<p>Write <code class="language-plaintext highlighter-rouge">V</code> to <code class="language-plaintext highlighter-rouge">out/file</code> in <code class="language-plaintext highlighter-rouge">binary</code> format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write(V, "out/file", format="binary");
</code></pre></div></div>

<p>Example content of <code class="language-plaintext highlighter-rouge">out/file.mtd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 10,
    "cols": 8,
    "nnz": 4,
    "rows_in_block": 1000,
    "cols_in_block": 1000,
    "format": "binary",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<p>Write <code class="language-plaintext highlighter-rouge">V</code> to <code class="language-plaintext highlighter-rouge">n.csv</code> in <code class="language-plaintext highlighter-rouge">csv</code> format with column headers, <code class="language-plaintext highlighter-rouge">";"</code> as delimiter, and zero values are not written.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write(V, "n.csv", format="csv", header=TRUE, sep=";", sparse=TRUE);
</code></pre></div></div>

<p>Example content of <code class="language-plaintext highlighter-rouge">n.csv.mtd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 3,
    "cols": 3,
    "nnz": 9,
    "format": "csv",
    "header": true,
    "sep": ";",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<p>Write <code class="language-plaintext highlighter-rouge">x</code> integer value to file <code class="language-plaintext highlighter-rouge">out/scalar_i</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write(x, "out/scalar_i");
</code></pre></div></div>

<p>Example content of <code class="language-plaintext highlighter-rouge">out/scalar_i.mtd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "scalar",
    "value_type": "int",
    "format": "text",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<p>Unlike <code class="language-plaintext highlighter-rouge">read</code>, the <code class="language-plaintext highlighter-rouge">write</code> function does not need a constant string expression, so the following example will work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = rand(rows=10, cols=2);
dir = "tmp/";
i = 1;
file = "A" + i + ".mtx";
write(A, dir + file, format="csv");
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">description</code> parameter can be used to attach a description to the metadata:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = matrix("1 2 3 4", rows=2, cols=2)
write(A, "mymatrix.csv", format="csv", description="my matrix")
</code></pre></div></div>

<p>This will generate the following <code class="language-plaintext highlighter-rouge">mymatrix.csv.mtd</code> metadata file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "matrix",
    "value_type": "double",
    "rows": 2,
    "cols": 2,
    "nnz": 4,
    "format": "csv",
    "header": false,
    "sep": ",",
    "description": "my matrix",
    "author": "SystemDS",
    "created": "2017-01-01 00:00:01 PST"
}
</code></pre></div></div>

<h3 id="data-pre-processing-built-in-functions">Data Pre-Processing Built-In Functions</h3>

<p>The data pre-processing built-in <code class="language-plaintext highlighter-rouge">transform()</code> function is used to transform a given tabular input data set (with data type <code class="language-plaintext highlighter-rouge">frame</code>) in CSV format into a <code class="language-plaintext highlighter-rouge">matrix</code>. The <code class="language-plaintext highlighter-rouge">transform()</code> function supports the following six column-level data transformations:</p>

<ul>
  <li><em>Omitting</em>: Given a list of columns, this transformation removes all rows which contain missing values for at least one of the specified columns.</li>
  <li><em>Missing Value Imputation</em>: This replaces missing data in individual columns with valid values, depending on the specific imputation method. There are three supported imputation methods &#8211; <code class="language-plaintext highlighter-rouge">global_mean</code> that replaces a missing value in a <em>numeric/scale</em> column with the mean of all non-missing entries in the column; <code class="language-plaintext highlighter-rouge">global_mode</code> that replaces a missing value in a <em>categorical</em> column with the mode of all non-missing entries in the column; and <code class="language-plaintext highlighter-rouge">constant</code> that replaces missing values in a <em>scale/categorical</em> column with the specified constant.</li>
  <li><em>Recoding</em>: This is applicable for <em>categorical</em> columns. It maps all distinct categories (potentially, strings and booleans) in the column into consecutive numbers, starting from 1. For example, a <code class="language-plaintext highlighter-rouge">direction</code> column with four distinct values (east, west, north, south) into a column with four numeric values 1.0, 2.0, 3.0, and 4.0.</li>
  <li><em>Binning</em>: This procedure is used to group a number of continuous values (i.e., discretize) into a small number of <em>bins</em>. For example, a column with <code class="language-plaintext highlighter-rouge">age</code> values can be discretized into a small number of age intervals. The only method that is currently supported is <code class="language-plaintext highlighter-rouge">equi-width</code> binning.</li>
  <li><em>Dummycoding</em>: This procedure transforms a categorical column into multiple columns of zeros and ones, which collectively capture the full information about the categorical variable. The number of resulting columns is equal to the number of distinct values in the input column. In the example of the <code class="language-plaintext highlighter-rouge">direction</code> variable mentioned above, this procedure replaces the original column with four new columns with zeros and ones – <code class="language-plaintext highlighter-rouge">direction_east</code>, <code class="language-plaintext highlighter-rouge">direction_west</code>, <code class="language-plaintext highlighter-rouge">direction_north</code>, and <code class="language-plaintext highlighter-rouge">direction_south</code>.</li>
  <li><em>Scaling</em>: This centers and/or scales the values in a given numeric/continuous column. The two supported methods are <code class="language-plaintext highlighter-rouge">mean-subtraction</code> that centers each value by subtracting the mean, and <code class="language-plaintext highlighter-rouge">z-score</code> that scales mean subtracted values by dividing them with the respective column-wise standard deviation.</li>
</ul>

<p>The transformations are specified to operate on individual columns. The set of all required transformations across all the columns in the input data must be provided via a <em>specification</em> file in JSON format. Furthermore, the notation indicating missing values must be specified using the <code class="language-plaintext highlighter-rouge">na.strings</code> property in the <code class="language-plaintext highlighter-rouge">mtd</code> file associated with the input CSV data, along with other properties such as <code class="language-plaintext highlighter-rouge">header</code> and <code class="language-plaintext highlighter-rouge">sep</code> (the delimiter). Note that the delimiter cannot be part of any value. For example, if a &#8220;,&#8221; (comma) is part of any value, then it cannot be used a delimiter. Users must choose a different <code class="language-plaintext highlighter-rouge">sep</code> value (e.g., a tab &#8220;\t&#8221;).</p>

<p>The following table indicates which transformations can be used simultaneously on a single column.</p>

<p><strong>Table 14</strong>: Data transformations that can be used simultaneously.</p>

<div style="float:left">
<table>
  <thead>
    <tr>
      <th>&nbsp;</th>
      <th>OMIT</th>
      <th>MVI</th>
      <th>RCD</th>
      <th>BIN</th>
      <th>DCD</th>
      <th>SCL</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="grayboldcell">OMIT</td>
      <td class="centerboldcell">-</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">MVI</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell">-</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">RCD</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell">-</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
    </tr>
    <tr>
      <td class="grayboldcell">BIN</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell">-</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
    </tr>
    <tr>
      <td class="grayboldcell">DCD</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell">-</td>
      <td class="centerboldcell lightred">x</td>
    </tr>
    <tr>
      <td class="grayboldcell">SCL</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell">-</td>
    </tr>
  </tbody>
</table>

</div>
<div style="float:left; margin-left:5px;">
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="boldcell">OMIT</td><td>Missing value handling by omitting</td></tr>
    <tr><td class="boldcell">MVI</td><td>Missing value handling by imputation</td></tr>
    <tr><td class="boldcell">RCD</td><td>Recoding</td></tr>
    <tr><td class="boldcell">BIN</td><td>Binning</td></tr>
    <tr><td class="boldcell">DCD</td><td>Dummycoding</td></tr>
    <tr><td class="boldcell">SCL</td><td>Scaling</td></tr>
  </tbody>
</table>
</div>
<div style="float:left; margin-left:5px;">
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="centerboldcell lightgreen">*</td><td>Combination is allowed</td></tr>
    <tr><td class="centerboldcell lightred">x</td><td>Combination is invalid</td></tr>
    <tr><td class="centerboldcell">-</td><td>Combination is not applicable</td></tr>
  </tbody>
</table>
</div>

<p><br style="clear: left;" />
<br /></p>

<p>The <code class="language-plaintext highlighter-rouge">transform()</code> function signature is shown here:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output = transform(target = input,
                   transformSpec = "/path/to/transformation/specification",
                   transformPath = "/path/to/transformation/metadata",
                   applyTransformPath = "/path/to/transformation/metadata")
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">target</code> parameter points to the input tabular data that needs to be transformed, the <code class="language-plaintext highlighter-rouge">transformSpec</code> parameter refers to the transformation specification JSON file indicating the list of transformations that must be performed, and <code class="language-plaintext highlighter-rouge">transformPath</code> denotes the output directory at which all the resulting metadata constructed during the transformation process is stored. Examples of such metadata include the number of distinct values in a categorical column, the list of distinct values and associated <em>recoded</em> IDs, the bin definitions (number of bins, bin widths), etc. This metadata can subsequently be utilized to transform new incoming data, for example, the test set in a predictive modeling exercise. The parameter <code class="language-plaintext highlighter-rouge">applyTransformPath</code> refers to existing transformation metadata which was generated by some earlier invocation of the <code class="language-plaintext highlighter-rouge">transform()</code> function. Therefore, in any invocation of <code class="language-plaintext highlighter-rouge">transform()</code>, only <code class="language-plaintext highlighter-rouge">transformSpec</code> <em>or</em> <code class="language-plaintext highlighter-rouge">applyTransformPath</code> can be specified. The transformation metadata is generated when <code class="language-plaintext highlighter-rouge">transformSpec</code> is specified, and it is used and applied when <code class="language-plaintext highlighter-rouge">applyTransformPath</code> is specified. On the other hand, the <code class="language-plaintext highlighter-rouge">transformPath</code> always refers to a location where the resulting transformation metadata is stored.</p>

<p>The <code class="language-plaintext highlighter-rouge">transform()</code> function returns the actual transformed data in the form of a matrix, containing only numeric values.</p>

<p>As an example of the <code class="language-plaintext highlighter-rouge">transform()</code> function, consider the following <a href="files/dml-language-reference/data.csv"><code class="language-plaintext highlighter-rouge">data.csv</code></a> file that represents a sample of homes data.</p>

<p><strong>Table 15</strong>: The <a href="files/dml-language-reference/data.csv"><code class="language-plaintext highlighter-rouge">data.csv</code></a> homes data set</p>

<table>
  <thead>
    <tr>
      <th>zipcode</th>
      <th>district</th>
      <th>sqft</th>
      <th>numbedrooms</th>
      <th>numbathrooms</th>
      <th>floors</th>
      <th>view</th>
      <th>saleprice</th>
      <th>askingprice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>95141</td>
      <td>south</td>
      <td>3002</td>
      <td>6</td>
      <td>3</td>
      <td>2</td>
      <td>FALSE</td>
      <td>929</td>
      <td>934</td>
    </tr>
    <tr>
      <td>NA</td>
      <td>west</td>
      <td>1373</td>
      <td>&#160;</td>
      <td>1</td>
      <td>3</td>
      <td>FALSE</td>
      <td>695</td>
      <td>698</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>south</td>
      <td>NA</td>
      <td>6</td>
      <td>2</td>
      <td>2</td>
      <td>FALSE</td>
      <td>902</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>94555</td>
      <td>NA</td>
      <td>1835</td>
      <td>3</td>
      <td>&#160;</td>
      <td>3</td>
      <td>&#160;</td>
      <td>888</td>
      <td>892</td>
    </tr>
    <tr>
      <td>95141</td>
      <td>west</td>
      <td>2770</td>
      <td>5</td>
      <td>2.5</td>
      <td>&#160;</td>
      <td>TRUE</td>
      <td>812</td>
      <td>816</td>
    </tr>
    <tr>
      <td>95141</td>
      <td>east</td>
      <td>2833</td>
      <td>6</td>
      <td>2.5</td>
      <td>2</td>
      <td>TRUE</td>
      <td>927</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>NA</td>
      <td>1339</td>
      <td>6</td>
      <td>3</td>
      <td>1</td>
      <td>FALSE</td>
      <td>672</td>
      <td>675</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>south</td>
      <td>2742</td>
      <td>6</td>
      <td>2.5</td>
      <td>2</td>
      <td>FALSE</td>
      <td>872</td>
      <td>876</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>north</td>
      <td>2195</td>
      <td>5</td>
      <td>2.5</td>
      <td>2</td>
      <td>FALSE</td>
      <td>799</td>
      <td>803</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>Note that the missing values are denoted either by an empty value or as a <code class="language-plaintext highlighter-rouge">String</code> &#8220;NA&#8221;. This information must be captured via the <code class="language-plaintext highlighter-rouge">na.strings</code> property in the metadata file associated with the input data. In this example, the data is stored in CSV format with &#8220;,&#8221; as the delimiter (the <code class="language-plaintext highlighter-rouge">sep</code> property). Recall that the delimiter cannot be part of any value. The metadata file <a href="files/dml-language-reference/data.csv.mtd"><code class="language-plaintext highlighter-rouge">data.csv.mtd</code></a> looks as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "frame",
    "format": "csv",
    "sep": ",",
    "header": true,
    "na.strings": [ "NA", "" ]
}
</code></pre></div></div>

<p>An example transformation specification file <a href="files/dml-language-reference/data.spec.json"><code class="language-plaintext highlighter-rouge">data.spec.json</code></a> is given below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "omit": [ "zipcode" ]
   ,"impute":
    [ { "name": "district"    , "method": "constant", "value": "south" }
     ,{ "name": "numbedrooms" , "method": "constant", "value": 2 }
     ,{ "name": "numbathrooms", "method": "constant", "value": 1 }
     ,{ "name": "floors"      , "method": "constant", "value": 1 }
     ,{ "name": "view"        , "method": "global_mode" }
     ,{ "name": "askingprice" , "method": "global_mean" }
     ,{ "name": "sqft"        , "method": "global_mean" }
    ]

    ,"recode":
    [ "zipcode", "district", "numbedrooms", "numbathrooms", "floors", "view" ]

    ,"bin":
    [ { "name": "saleprice"  , "method": "equi-width", "numbins": 3 }
     ,{ "name": "sqft"       , "method": "equi-width", "numbins": 4 }
    ]

    ,"dummycode":
    [ "district", "numbathrooms", "floors", "view", "saleprice", "sqft" ]

}
</code></pre></div></div>

<p>The following DML utilizes the <code class="language-plaintext highlighter-rouge">transform()</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D = read("/user/ml/data.csv");
tfD = transform(target=D,
                transformSpec="/user/ml/data.spec.json",
                transformPath="/user/ml/data-transformation");
s = sum(tfD);
print("Sum = " + s);
</code></pre></div></div>

<p>The transformation specification file can also utilize column numbers rather than than column names by setting
the <code class="language-plaintext highlighter-rouge">ids</code> property to true.
The following <a href="files/dml-language-reference/data.spec2.json"><code class="language-plaintext highlighter-rouge">data.spec2.json</code></a> specification file is the equivalent of the
aforementioned <a href="files/dml-language-reference/data.spec.json"><code class="language-plaintext highlighter-rouge">data.spec.json</code></a> file but with column numbers
rather than column names.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "ids": true
    ,"omit" : [ 1 ]
    ,"impute":
    [ { "id": 2, "method": "constant", "value": "south" }
     ,{ "id": 4, "method": "constant", "value": 2 }
     ,{ "id": 5, "method": "constant", "value": 1 }
     ,{ "id": 6, "method": "constant", "value": 1 }
     ,{ "id": 7, "method": "global_mode" }
     ,{ "id": 9, "method": "global_mean" }
     ,{ "id": 3, "method": "global_mean" }
    ]

    ,"recode": [ 1, 2, 4, 5, 6, 7 ]

    ,"bin":
    [ { "id": 8, "method": "equi-width", "numbins": 3 }
     ,{ "id": 3, "method": "equi-width", "numbins": 4 }
    ]

    ,"dummycode": [ 2, 5, 6, 7, 8, 3 ]

}
</code></pre></div></div>

<p>As a further JSON transformation specification example, the following <a href="files/dml-language-reference/data.spec3.json"><code class="language-plaintext highlighter-rouge">data.spec3.json</code></a> file specifies <em>scaling</em> transformations on three columns.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "omit": [ "zipcode" ]
   ,"impute":
    [ { "name": "district"    , "method": "constant", "value": "south" }
     ,{ "name": "numbedrooms" , "method": "constant", "value": 2 }
     ,{ "name": "numbathrooms", "method": "constant", "value": 1 }
     ,{ "name": "floors"      , "method": "constant", "value": 1 }
     ,{ "name": "view"        , "method": "global_mode" }
     ,{ "name": "askingprice" , "method": "global_mean" }
     ,{ "name": "sqft"        , "method": "global_mean" }
    ]

    ,"recode":
    [ "zipcode", "district", "numbedrooms", "numbathrooms", "floors", "view" ]

    ,"dummycode":
    [ "district", "numbathrooms", "floors", "view" ]

    ,"scale":
    [ { "name": "sqft", "method": "mean-subtraction" }
     ,{ "name": "saleprice", "method": "z-score" }
     ,{ "name": "askingprice", "method": "z-score" }
    ]
}
</code></pre></div></div>

<p>The following code snippet shows an example scenario of transforming a training data set and subsequently testing the data set.</p>

<h4 id="training-phase">Training Phase</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Train = read("/user/ml/trainset.csv");
trainD = transform(target=Train,
                   transformSpec="/user/ml/tf.spec.json",
                   transformPath="/user/ml/train_tf_metadata");
# Build a predictive model using trainD
...
</code></pre></div></div>

<h4 id="testing-phase">Testing Phase</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Test = read("/user/ml/testset.csv");
testD = transform(target=Test,
                  transformPath="/user/ml/test_tf_metadata",
                  applyTransformPath="/user/ml/train_tf_metdata");
# Test the model using testD
...
</code></pre></div></div>

<p>Note that the metadata generated during the training phase (located at <code class="language-plaintext highlighter-rouge">/user/ml/train_tf_metadata</code>) is used to apply the list of transformations (that were carried out on training data set) on the test data set. Since the second invocation of <code class="language-plaintext highlighter-rouge">transform()</code> does not really generate any new metadata data, the given metadata (<code class="language-plaintext highlighter-rouge">/user/ml/train_tf_metdata</code>) is copied to the target location (<code class="language-plaintext highlighter-rouge">/user/ml/test_tf_metdata</code>). Even though such a behavior creates redundant copies of transformation metadata, it is preferred as it allows the association of every data set with the corresponding transformation metadata.</p>

<h3 id="deep-learning-built-in-functions">Deep Learning Built-In Functions</h3>

<p>SystemDS represent a tensor as a matrix stored in a row-major format,
where first dimension of tensor and matrix are exactly the same. For example, a tensor (with all zeros)
of shape [3, 2, 4, 5] can be instantiated by following DML statement:</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A <span class="o">=</span> matrix<span class="o">(</span>0, <span class="nv">rows</span><span class="o">=</span>3, <span class="nv">cols</span><span class="o">=</span>2<span class="k">*</span>4<span class="k">*</span>5<span class="o">)</span> 
</code></pre></div></div>

<p>The images are assumed to be stored NCHW format, where N = batch size, C = #channels, H = height of image and W = width of image. 
Hence, the images are internally represented as a matrix with dimension (N, C * H * W).</p>

<table>
  <thead>
    <tr>
      <th>Function name</th>
      <th>Input matrices</th>
      <th>Dimension of first input matrix</th>
      <th>Dimension of second input matrix (if applicable)</th>
      <th>Dimension of (first) output matrix</th>
      <th>Input Parameters</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conv2d</td>
      <td>input, filter</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[num_filters X num_channels* height_filter* width_filter]</td>
      <td>[batch_size X num_channels_out* height_out* width_out]</td>
      <td>stride=[stride_h, stride_w], padding=[pad_h, pad_w], input_shape=[batch_size, num_channels, height_image, width_image], filter_shape=[num_filters, num_channels, height_filter, width_filter]</td>
      <td>Performs 2D convolution operation</td>
    </tr>
    <tr>
      <td>conv2d_backward_filter</td>
      <td>input, dout</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[batch_size X num_channels_out* height_out* width_out]</td>
      <td>[num_filters X num_channels* height_filter* width_filter]</td>
      <td>stride=[stride_h, stride_w], padding=[pad_h, pad_w], input_shape=[batch_size, num_channels, height_image, width_image], filter_shape=[num_filters, num_channels, height_filter, width_filter]</td>
      <td>Computes the gradients wrt filter of 2D convolution</td>
    </tr>
    <tr>
      <td>conv2d_backward_data</td>
      <td>filter, dout</td>
      <td>[num_filters X num_channels* height_filter* width_filter]</td>
      <td>[batch_size X num_channels_out* height_out* width_out]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>stride=[stride_h, stride_w], padding=[pad_h, pad_w], input_shape=[batch_size, num_channels, height_image, width_image], filter_shape=[num_filters, num_channels, height_filter, width_filter]</td>
      <td>Computes the gradients wrt input of 2D convolution</td>
    </tr>
    <tr>
      <td>max_pool, avg_pool</td>
      <td>input</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>&#160;</td>
      <td>[batch_size X num_channels* height_out* width_out]</td>
      <td>stride=[stride_h, stride_w], padding=[pad_h, pad_w], input_shape=[batch_size, num_channels, height_image, width_image], pool_size=[height_pool, width_pool]</td>
      <td>Performs max/average pooling operation</td>
    </tr>
    <tr>
      <td>max_pool_backward, avg_pool_backward</td>
      <td>input, dout</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[batch_size X num_channels* height_out* width_out]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>stride=[stride_h, stride_w], padding=[pad_h, pad_w], input_shape=[batch_size, num_channels, height_image, width_image], pool_size=[height_pool, width_pool]</td>
      <td>Computes the gradients wrt input of 2D max pooling, average pooling</td>
    </tr>
    <tr>
      <td>bias_add</td>
      <td>input, bias</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[num_channels X 1]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>&#160;</td>
      <td>Adds the bias (row vector of size num_channels) to input with the given num_channels</td>
    </tr>
    <tr>
      <td>bias_multiply</td>
      <td>input, bias</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[num_channels X 1]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>&#160;</td>
      <td>Multiplies the bias (row vector of size num_channels) to input with the given num_channels</td>
    </tr>
    <tr>
      <td>lstm</td>
      <td>X,  W, bias, out0, c0</td>
      <td>[batch_size X seq_length*num_features]</td>
      <td>[num_features+hidden_size X 4*hidden_size]</td>
      <td>[batch_size X seq_length*hidden_size] if return_sequences else  [batch_size X hidden_size]</td>
      <td>return_sequences</td>
      <td>Perform computation for single-layer unidirectional LSTM (outputs: out, carryOut)</td>
    </tr>
    <tr>
      <td>batch_norm2d</td>
      <td>input</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>&#160;</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>scale, shift, exponentialMovingAverage_Mean, exponentialMovingAverage_Variance, mode, epsilon, momentum</td>
      <td>Performs batch normalization operation  (outputs: updated exponential moving average mean and variance, cache of the batch mean and variance)</td>
    </tr>
    <tr>
      <td>batch_norm2d_backward</td>
      <td>input, dout</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>[batch_size X num_channels* height_image* width_image]</td>
      <td>scale, epsilon, cache_mean (from forward), cache_inv_var (from forward)</td>
      <td>Computed backpropagation error for batch normalization operation</td>
    </tr>
  </tbody>
</table>

<p>Note: the builtin functions <code class="language-plaintext highlighter-rouge">batch_norm2d</code> and <code class="language-plaintext highlighter-rouge">batch_norm2d_backward</code> are deprecated and will be removed in the next release. The <code class="language-plaintext highlighter-rouge">lstm</code> builtin function is in experimental phase and is only supported for the GPU backend.</p>

<p>Examples:</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Parameters</th>
      <th>Visualization / Equivalent DML</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>conv2d</td>
      <td>stride=[1,1]</td>
      <td><img src="img/dml-language-reference/Conv2d.gif" alt="conv2d with stride 1" title="conv2d with stride 1" /></td>
    </tr>
    <tr>
      <td>conv2d</td>
      <td>stride=[2,2]</td>
      <td><img src="img/dml-language-reference/Conv2d1.gif" alt="conv2d with stride 2" title="conv2d with stride 2" /></td>
    </tr>
    <tr>
      <td>conv2d_backward_data</td>
      <td>stride=[1,1]</td>
      <td><img src="img/dml-language-reference/Conv2d_backward_data.gif" alt="conv2d_backward_data with stride 1" title="conv2d_backward_data with stride 1" /></td>
    </tr>
    <tr>
      <td>conv2d_backward_data</td>
      <td>stride=[2,2]</td>
      <td><img src="img/dml-language-reference/Conv2d_backward_data1.gif" alt="conv2d_backward_data with stride 2" title="conv2d_backward_data with stride 2" /></td>
    </tr>
    <tr>
      <td>conv2d_backward_data</td>
      <td>stride=[2,2] and 2x2 filter</td>
      <td><img src="img/dml-language-reference/Conv2d_backward_data1.gif" alt="conv2d_backward_data with stride 2 2x2 filter" title="conv2d_backward_data with stride 2 with 2x2 filter" /></td>
    </tr>
    <tr>
      <td>bias_add</td>
      <td>&#160;</td>
      <td><code class="language-plaintext highlighter-rouge">ones = matrix(1, rows=1, cols=height*width); output = input + matrix(bias %*% ones, rows=1, cols=numChannels*height*width)</code></td>
    </tr>
    <tr>
      <td>bias_multiply</td>
      <td>&#160;</td>
      <td><code class="language-plaintext highlighter-rouge">ones = matrix(1, rows=1, cols=height*width); output = input * matrix(bias %*% ones, rows=1, cols=numChannels*height*width)</code></td>
    </tr>
  </tbody>
</table>

<h3 id="parameter-server-built-in-function">Parameter Server Built-in Function</h3>
<p>Apart from data-parallel operations and task-parallel parfor loops, SystemDS also supports a <strong>data-parallel Parameter Server</strong> via a built-in function <strong>paramserv</strong>. Currently both local multi-threaded and spark distributed backend are supported to execute the <strong>paramserv</strong> function. So far we only support a single parameter server with N workers as well as synchronous and asynchronous model updates per batch or epoch. For example, in order to train a model in local backend with update strategy BSP, 10 epochs, 64 batchsize, 10 workers, <strong>paramserv</strong> function should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resultModel=paramserv(model=initModel, features=X, labels=Y, 
                      upd="fun1", agg="fun2", epochs=10, k=10, hyperparams=hParams)
</code></pre></div></div>

<p><strong>Table</strong>: Inputs of paramserv function</p>

<table>
  <thead>
    <tr>
      <th>Parameters</th>
      <th>Description</th>
      <th>Type</th>
      <th>Mandatory</th>
      <th>Options</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>model</td>
      <td>All the parameters (e.g., the weight and bias matrices)</td>
      <td>list</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>features</td>
      <td>Training features</td>
      <td>matrix</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>labels</td>
      <td>Training labels</td>
      <td>matrix</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>val_features</td>
      <td>Validation features</td>
      <td>matrix</td>
      <td>no</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>val_labels</td>
      <td>Validation labels</td>
      <td>matrix</td>
      <td>no</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>upd</td>
      <td>Physical name of gradient calculation function. The format should be &#8220;related path:func name&#8221;. For example, &#8220;./mnist_lenet_paramserv_sgd.dml::gradients&#8221;.</td>
      <td>string</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>agg</td>
      <td>Physical name of gradient aggregation function. The format should be &#8220;related path:func name&#8221;. For example, &#8220;./mnist_lenet_paramserv_sgd.dml::aggregation&#8221;.</td>
      <td>string</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>mode</td>
      <td>Execution backend for data partitioning and worker execution</td>
      <td>string</td>
      <td>no</td>
      <td>&#8220;LOCAL&#8221;(default), &#8220;REMOTE_SPARK&#8221;</td>
    </tr>
    <tr>
      <td>utype</td>
      <td>Update strategy</td>
      <td>string</td>
      <td>no</td>
      <td>&#8220;ASP&#8221;(default), &#8220;BSP&#8221;</td>
    </tr>
    <tr>
      <td>freq</td>
      <td>Frequency of model updating</td>
      <td>string</td>
      <td>no</td>
      <td>&#8220;EPOCH&#8221;(default), &#8220;BATCH&#8221;</td>
    </tr>
    <tr>
      <td>epochs</td>
      <td>Number of epochs, where an epoch is a full scan over the data</td>
      <td>integer</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>batchsize</td>
      <td>Size of a mini-batch (number of rows)</td>
      <td>integer</td>
      <td>no</td>
      <td>64(default)</td>
    </tr>
    <tr>
      <td>k</td>
      <td>Number of workers</td>
      <td>integer</td>
      <td>no</td>
      <td>Number of vcores(default)</td>
    </tr>
    <tr>
      <td>scheme</td>
      <td>Scheme of data partition, i.e., how the data is distributed across workers</td>
      <td>string</td>
      <td>no</td>
      <td>&#8220;DISJOINT_CONTIGUOUS&#8221;(default), &#8220;DISJOINT_ROUND_ROBIN&#8221;, &#8220;DISJOINT_RANDOM&#8221;, &#8220;OVERLAP_RESHUFFLE&#8221;</td>
    </tr>
    <tr>
      <td>hyperparams</td>
      <td>Additional hyper parameters, e.g., learning rate, momentum</td>
      <td>list</td>
      <td>yes</td>
      <td>&#160;</td>
    </tr>
    <tr>
      <td>checkpointing</td>
      <td>Checkpoint strategy, currently not supported</td>
      <td>string</td>
      <td>no</td>
      <td>&#160;</td>
    </tr>
  </tbody>
</table>

<p><strong>Table</strong>: Output of paramserv function</p>

<table>
  <thead>
    <tr>
      <th>Output</th>
      <th>Description</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>model</td>
      <td>Trained model</td>
      <td>list</td>
    </tr>
  </tbody>
</table>

<p><strong>Update function:</strong></p>

<p>The update function calculates the gradients for a single mini-batch and the given model (e.g., via a forward and backward pass through a neural network). The implementation of this function should be based on a function signature like this: (i.e., <strong>the input parameter including both type and name should be exactly the same as the below, except that the output name could be different</strong>)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gradients <span class="o">=</span> <span class="k">function</span><span class="o">(</span>list[unknown] model, list[unknown] hyperparams,
                     matrix[double] features, matrix[double] labels<span class="o">)</span>
          <span class="k">return</span> <span class="o">(</span>list[unknown] gradients<span class="o">)</span>
          <span class="c"># the output name can be something else than "gradients" but should always return a list</span>
</code></pre></div></div>

<p><strong>Aggregate function:</strong></p>

<p>The aggregate function then takes the computed or accrued gradients and updates the model via some optimizer such as Adagrad or Adam. The implementation of this function should be based on a function signature like this: (i.e., <strong>the input parameter including both type and name should be exactly the same as the below, except that the output name could be different</strong>)</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregation <span class="o">=</span> <span class="k">function</span><span class="o">(</span>list[unknown] model, list[unknown] hyperparams,
                       list[unknown] gradients<span class="o">)</span>
         <span class="k">return</span> <span class="o">(</span>list[unknown] modelResult<span class="o">)</span>
         <span class="c"># the output name can be something else than "modelResult" but should always return a list</span>
</code></pre></div></div>

<p><strong>Update strategy:</strong></p>

<p>Currently, two types of update strategy, <strong>ASP</strong> and <strong>BSP</strong>, are supported. <strong>ASP</strong>, a.k.a. <em>Asynchronous Parallel</em>, means that the model updates will be completed in an asynchronous manner. The parameter server updates the model and broadcasts the updated model immediately with the fresh gradients pushed by the worker and then the worker is able to pull the new updated model. This push-and-pull process is done asynchronously across workers. While <strong>BSP</strong>, a.k.a. <em>Bulk Synchronous Parallel</em>, the server will update the global model until having received all the gradients sent by workers in one iteration and then workers could move into the next iteration. Hence, the overall performance is affected by stragglers (i.e., the slowest worker).</p>

<p><strong>Update frequency:</strong></p>

<p>When pushing the gradients from workers to server for updating the model, we could determine how often this push-and-pull process will be done. Currently, two types of update frequency, <strong>EPOCH</strong> and <strong>BATCH</strong> are supported. When setting to <strong>EPOCH</strong>, the generated gradients of each mini-batch are accumulated locally in each worker. The accrued gradients are then pushed to the server whenever a worker finished an epoch. While setting to <strong>BATCH</strong>, the generated gradients of each mini-batch are pushed to server immediately to launch the push-and-pull process.</p>

<p><strong>Data partition schemes:</strong></p>

<p>Before launching the data-parallel parameter server, the original data will be partitioned across workers according to some schemes. Currently, four types of schemes are supported, Disjoint_Contigous, Disjoint_Round_Robin, Disjoint_Random, Overlap_Reshuffle.</p>

<table>
  <thead>
    <tr>
      <th>Scheme</th>
      <th>Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Disjoint_Contiguous</td>
      <td>For each worker, use a right indexing operation X[beg:end,] to obtain contiguous, non-overlapping partitions of rows</td>
    </tr>
    <tr>
      <td>Disjoint_Round_Robin</td>
      <td>For each worker, use a permutation multiply or simpler a removeEmpty such as removeEmpty(target=X, margin=rows, select=(seq(1,nrow(X))%%k)==id)</td>
    </tr>
    <tr>
      <td>Disjoint_Random</td>
      <td>For each worker, use a permutation multiply P[beg:end,] %*% X, where P is constructed for example with P=table(seq(1,nrow(X)),sample(nrow(X), nrow(X))), i.e., sampling without replacement to ensure disjointness</td>
    </tr>
    <tr>
      <td>Overlap_Reshuffle</td>
      <td>Similar to the above, except to create a new permutation matrix for each worker and without the indexing on P</td>
    </tr>
  </tbody>
</table>

<h3 id="other-built-in-functions">Other Built-In Functions</h3>

<p><strong>Table 16</strong>: Other Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>append()</td>
      <td>Append a string to another string separated by &#8220;\n&#8221; <br /> Limitation: The string may grow up to 1 MByte.</td>
      <td>Input: (&lt;string&gt;, &lt;string&gt;) <br /> Output: &lt;string&gt;</td>
      <td>s = &#8220;iter=&#8221; + i <br /> i = i + 1 <br /> s = append(s, &#8220;iter=&#8221; + i) <br /> write(s, &#8220;s.out&#8221;)</td>
    </tr>
    <tr>
      <td>toString()</td>
      <td>Formats a Matrix or Frame object into a string. <br /> &#8220;rows&#8221; &amp; &#8220;cols&#8221; : number of rows and columns to print<br /> &#8220;decimal&#8221; : number of digits after the decimal<br />&#8220;sparse&#8221; : set to TRUE to print Matrix object in sparse format, i.e. <em>RowIndex</em> <em>ColIndex</em> <em>Value</em><br />&#8220;sep&#8221; and &#8220;linesep&#8221; : inter-element separator and the line separator strings</td>
      <td>Input : (&lt;matrix&gt; or &lt;frame&gt;,<br /> &#160;&#160;rows=100,<br /> &#160;&#160;cols=100,<br /> &#160;&#160;decimal=3,<br /> &#160;&#160;sparse=FALSE,<br /> &#160;&#160;sep=&#8221; &#8220;,<br /> &#160;&#160;linesep=&#8221;\n&#8221;) <br /> Output: &lt;string&gt;</td>
      <td>X = matrix(seq(1, 9), rows=3, cols=3)<br />str = toString(X, sep=&#8221; | &#8220;) <br /><br />F = as.frame(X)<br />print(toString(F, rows=2, cols=2))</td>
    </tr>
    <tr>
      <td>print()</td>
      <td>Prints a scalar variable. The print() function allows printf-style formatting by optionally allowing multiple arguments, where the first argument is the string that specifies the formatting and the additional arguments are the arguments to format.</td>
      <td>Input: &lt;scalar&gt;<br />or<br />&lt;string, args&#8230;&gt;</td>
      <td>print(&#8220;hello&#8221;) <br /> print(&#8220;hello&#8221; + &#8220;world&#8221;) <br /> print(&#8220;value of x is &#8220; + x ) <br /><br />a=&#8217;hello&#8217;;<br />b=3;<br />c=4.5;<br />d=TRUE;<br />print(&#8216;%s %d %f %b&#8217;, a, b, c, d); <br /><br />a=&#8217;hello&#8217;;<br />b=&#8217;goodbye&#8217;;<br />c=4;<br />d=3;<br />e=3.0;<br />f=5.0;<br />g=FALSE;<br />print(&#8216;%s %d %f %b&#8217;, (a+b), (c-d), (e*f), !g);</td>
    </tr>
    <tr>
      <td>stop()</td>
      <td>Halts the execution of DML program by printing the message that is passed in as the argument. <br /> Note that the use of stop() is not allowed inside a parfor loop.</td>
      <td>Input: (&lt;scalar&gt;)</td>
      <td>stop(&#8220;Inputs to DML program are invalid&#8221;) <br /> stop(&#8220;Class labels must be either -1 or +1&#8221;)</td>
    </tr>
    <tr>
      <td>assert()</td>
      <td>Halts the execution of DML program if the boolean argument doesnot evaluate to TRUE. <br /> Note that the use of assert() is not allowed inside a parfor loop.</td>
      <td>Input: (&lt;scalar of type boolean&gt;)</td>
      <td>assert(1 != 2)</td>
    </tr>
    <tr>
      <td>order()</td>
      <td>Sort a column of the matrix X in decreasing/increasing order and return either index (index.return=TRUE) or data (index.return=FALSE).</td>
      <td>Input: (target=X, by=column, decreasing, index.return)</td>
      <td>order(X, by=1, decreasing=FALSE, index.return=FALSE)</td>
    </tr>
    <tr>
      <td>ifelse()</td>
      <td>Conditional selection of inputs or input cells (if the first input is true or non-zero, select the second otherwise the third input). If all inputs are scalars, the output is a scalar; otherwise a matrix of same size as the input matrices.</td>
      <td>Input: three inputs, any combinations of matrices and scalars</td>
      <td>ifelse(x, Y, Z) <br /> ifelse(X, Y, -1)</td>
    </tr>
  </tbody>
</table>

<h2 id="frames">Frames</h2>

<p>The <code class="language-plaintext highlighter-rouge">frame</code> data type represents tabular data.  In contrast to a <code class="language-plaintext highlighter-rouge">matrix</code>, whose element values are of type <code class="language-plaintext highlighter-rouge">double</code>, a <code class="language-plaintext highlighter-rouge">frame</code> can be associated with a schema to specify additional value types.  Frames can be read from and written to files and support both left and right indexing.    Built-in functions are provided to convert between frames and matrices.  Advanced transform operations can also be applied.  Note that frames are only supported for standalone and spark modes.</p>

<h3 id="creating-frames">Creating Frames</h3>

<p>To create a <code class="language-plaintext highlighter-rouge">frame</code>, specify <code>data_type="frame"</code> when reading data from a file.  Input formats csv, text, and binary are supported.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = read("fileA", data_type="frame", rows=10, cols=8);
B = read("dataB", data_type="frame", rows=3, cols=3, format="csv");
</code></pre></div></div>

<p>A schema can be specified when creating a <code class="language-plaintext highlighter-rouge">frame</code> where the schema is a string containing a value type per column.  The supported value types for a schema are <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">boolean</code>.  Note <code>schema=""</code> resolves to a string schema and if no schema is specified, the default is <code>""</code>.</p>

<p>This example shows creating a frame with <code>schema="string,double,int,boolean"</code> since the data has four columns (one of each supported value type).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tableSchema = "string,double,int,boolean";
C = read("tableC", data_type="frame", schema=tableSchema, rows=1600, cols=4, format="csv");
</code></pre></div></div>

<p><em>Note: the header line in frame CSV files is sensitive to white spaces.</em> <br />
For example, CSV1 with header <code>ID,FirstName,LastName</code> results in three columns with tokens between separators.  In contrast, CSV2 with header <code>ID, FirstName,LastName</code> also results in three columns but the second column has a space preceding <code> FirstName</code>.  This extra space is significant when referencing the second column by name in transform specifications as described in <a href="#transforming-frames">Transforming Frames</a>.</p>

<div class="codetabs2">

<div data-lang="CSV1">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID,FirstName,LastName
1,FirstName1,LastName1
2,FirstName2,LastName2
</code></pre></div>    </div>
  </div>

<div data-lang="CSV2">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID, FirstName,LastName
1,FirstName1,LastName1
2,FirstName2,LastName2
</code></pre></div>    </div>
  </div>

<div data-lang="CSV MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "frame",
    "format": "csv",
    "header": true
}
</code></pre></div>    </div>
  </div>

</div>

<h3 id="appending-frames">Appending Frames</h3>

<p>Built-In functions <code>cbind()</code> and <code>rbind()</code> are supported for frames to add columns or rows to an existing frame.</p>

<p><strong>Table F1</strong>: Frame Append Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>cbind()</td>
      <td>Column-wise frame concatenation. Concatenates the second frame as additional columns to the first frame.</td>
      <td>Input: (X &lt;frame&gt;, Y &lt;frame&gt;) <br />Output: &lt;frame&gt; <br /> X and Y are frames, where the number of rows in X and the number of rows in Y are the same.</td>
      <td>A = read(&#8220;file1&#8221;, data_type=&#8221;frame&#8221;, rows=2, cols=3, format=&#8221;binary&#8221;) <br /> B = read(&#8220;file2&#8221;, data_type=&#8221;frame&#8221;, rows=2, cols=3, format=&#8221;binary&#8221;) <br /> C = cbind(A, B) <br /> # Dimensions of C: 2 X 6</td>
    </tr>
    <tr>
      <td>rbind()</td>
      <td>Row-wise frame concatenation. Concatenates the second frame as additional rows to the first frame.</td>
      <td>Input: (X &lt;fame&gt;, Y &lt;frame&gt;) <br />Output: &lt;frame&gt; <br /> X and Y are frames, where the number of columns in X and the number of columns in Y are the same.</td>
      <td>A = read(&#8220;file1&#8221;, data_type=&#8221;frame&#8221;, rows=2, cols=3, format=&#8221;binary&#8221;) <br /> B = read(&#8220;file2&#8221;, data_type=&#8221;frame&#8221;, rows=2, cols=3, format=&#8221;binary&#8221;) <br /> C = rbind(A, B) <br /> # Dimensions of C: 4 X 3</td>
    </tr>
  </tbody>
</table>

<h3 id="indexing-frames">Indexing Frames</h3>

<p>Similar to matrices, frames support both right and left indexing.  Note for left indexing, the right hand side frame size and selected left hand side frame slice must match.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># = [right indexing]
A = read("inputA", data_type="frame", rows=10, cols=10, format="binary")
B = A[4:5, 6:7]
C = A[1, ]
D = A[, 3]
E = A[, 1:2]

# [left indexing] =
F = read("inputF", data_type="frame", rows=10, cols=10, format="binary")
F[4:5, 6:7] = B
F[1, ] = C
F[, 3] = D
F[, 1:2] = E
</code></pre></div></div>

<h3 id="casting-frames">Casting Frames</h3>

<p>Frames support converting between matrices and scalars using <code>as.frame(), as.matrix()</code> and <code>as.scalar()</code>.  Casting a frame to a matrix is a best effort operation, which tries to parse doubles.  If there are strings that cannot be parsed, the <code>as.frame()</code> operation produces errors.  For example, a <code>java.lang.NumberFormatException</code> may occur for invalid data since Java&#8217;s <code>Double.parseDouble()</code> is used internally for parsing.</p>

<p><strong>Table F2</strong>: Casting Built-In Functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>as.frame(&lt;matrix&gt;)</td>
      <td>Matrix is cast to frame.</td>
      <td>Input: (&lt;matrix&gt;) <br /> Output: &lt;frame&gt;</td>
      <td>A = read(&#8220;inputMatrixDataFile&#8221;) <br /> B = as.frame(A) <br />write(B, &#8220;outputFrameDataFile&#8221;, format=&#8221;binary&#8221;)</td>
    </tr>
    <tr>
      <td>as.frame(&lt;scalar&gt;)</td>
      <td>Scalar is cast to 1x1 frame.</td>
      <td>Input: (&lt;scalar&gt;) <br /> Output: &lt;frame&gt;</td>
      <td>A = read(&#8220;inputScalarData&#8221;, data_type=&#8221;scalar&#8221;, value_type=&#8221;string&#8221;) <br /> B = as.frame(A) <br /> write(B, &#8220;outputFrameData&#8221;)</td>
    </tr>
    <tr>
      <td>as.matrix(&lt;frame&gt;)</td>
      <td>Frame is cast to matrix.</td>
      <td>Input: (&lt;frame&gt;) <br /> Output: &lt;matrix&gt;</td>
      <td>B = read(&#8220;inputFrameDataFile&#8221;) <br /> C = as.matrix(B) <br />write(C, &#8220;outputMatrixDataFile&#8221;, format=&#8221;binary&#8221;)</td>
    </tr>
    <tr>
      <td>as.scalar(&lt;frame&gt;)</td>
      <td>1x1 Frame is cast to scalar.</td>
      <td>Input: (&lt;frame&gt;) <br /> Output: &lt;scalar&gt;</td>
      <td>B = read(&#8220;inputFrameData&#8221;, data_type=&#8221;frame&#8221;, schema=&#8221;string&#8221;, rows=1, cols=1) <br /> C = as.scalar(B) <br /> write(C, &#8220;outputScalarData&#8221;)</td>
    </tr>
  </tbody>
</table>

<p><em>Note: <code>as.frame(matrix)</code> produces a double schema, and <code>as.scalar(frame)</code> produces of scalar of value type given by the frame schema.</em></p>

<h3 id="transforming-frames">Transforming Frames</h3>

<p>Frames support additional <a href="#data-pre-processing-built-in-functions">Data Pre-Processing Built-In Functions</a> as shown below.</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>transformencode()</td>
      <td>Transforms a frame into a matrix using specification. <br /> Builds and applies frame metadata.</td>
      <td>Input:<br /> target = &lt;frame&gt; <br /> spec = &lt;json specification&gt; <br /> Outputs: &lt;matrix&gt;, &lt;frame&gt;</td>
      <td><a href="#transformencode">transformencode</a></td>
    </tr>
    <tr>
      <td>transformdecode()</td>
      <td>Transforms a matrix into a frame using specification. <br /> Valid only for specific transformation types.</td>
      <td>Input:<br /> target = &lt;matrix&gt; <br /> spec = &lt;json specification&gt; <br /> meta = &lt;frame&gt; <br /> Output: &lt;frame&gt;</td>
      <td><a href="#transformdecode">transformdecode</a></td>
    </tr>
    <tr>
      <td>transformapply()</td>
      <td>Transforms a frame into a matrix using specification. <br /> Applies existing frame metadata.</td>
      <td>Input:<br /> target = &lt;frame&gt; <br /> spec = &lt;json specification&gt; <br /> meta = &lt;frame&gt; <br /> Output: &lt;matrix&gt;</td>
      <td><a href="#transformapply">transformapply</a></td>
    </tr>
    <tr>
      <td>transformcolmap()</td>
      <td>Obtains the column mapping of a transformed frame using the given specification. The input frame is assumed to be the meta data frame returned from a transformencode call. <br /> The output has a row per encoded input attribute, indicating the source column position, as well as the start and end positions in the encode output.</td>
      <td>Input:<br /> target = &lt;frame&gt; <br /> spec = &lt;json specification&gt; <br /> Output: &lt;matrix&gt;</td>
      <td><a href="#transformdecode">transformcolmap</a></td>
    </tr>
  </tbody>
</table>

<p>The following table summarizes the supported transformations for <code>transformencode(), transformdecode(), transformapply()</code>.  Note only recoding, dummy coding and pass-through are reversible, i.e., subject to <code>transformdecode()</code>, whereas binning, missing value imputation, and omit are not.</p>

<p><strong>Table F3</strong>: Frame data transformation types.</p>

<div style="float:left">
<table>
  <thead>
    <tr>
      <th>&nbsp;</th>
      <th>encode</th>
      <th>decode</th>
      <th>apply</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="grayboldcell">RCD</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">DCD</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">BIN</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">MVI</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
    <tr>
      <td class="grayboldcell">OMIT</td>
      <td class="centerboldcell lightgreen">*</td>
      <td class="centerboldcell lightred">x</td>
      <td class="centerboldcell lightgreen">*</td>
    </tr>
  </tbody>
</table>

</div>
<div style="float:left; margin-left:5px;">
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="boldcell">RCD</td><td>Recoding</td></tr>
    <tr><td class="boldcell">DCD</td><td>Dummycoding</td></tr>
    <tr><td class="boldcell">BIN</td><td>Binning</td></tr>
    <tr><td class="boldcell">MVI</td><td>Missing value handling by imputation</td></tr>
    <tr><td class="boldcell">OMIT</td><td>Missing value handling by omitting</td></tr>
  </tbody>
</table>
</div>
<div style="float:left; margin-left:5px;">
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr><td class="centerboldcell lightgreen">*</td><td>Supported</td></tr>
    <tr><td class="centerboldcell lightred">x</td><td>Not supported</td></tr>
  </tbody>
</table>
</div>

<p><br style="clear: left;" />
<br /></p>

<p>The following examples use <a href="files/dml-language-reference/homes.csv"><code class="language-plaintext highlighter-rouge">homes.csv</code></a> data set.</p>

<p><strong>Table F4</strong>: The <a href="files/dml-language-reference/homes.csv"><code class="language-plaintext highlighter-rouge">homes.csv</code></a> data set</p>

<table>
  <thead>
    <tr>
      <th>zipcode</th>
      <th>district</th>
      <th>sqft</th>
      <th>numbedrooms</th>
      <th>numbathrooms</th>
      <th>floors</th>
      <th>view</th>
      <th>saleprice</th>
      <th>askingprice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>95141</td>
      <td>west</td>
      <td>1373</td>
      <td>7</td>
      <td>1</td>
      <td>3</td>
      <td>FALSE</td>
      <td>695</td>
      <td>698</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>south</td>
      <td>3261</td>
      <td>6</td>
      <td>2</td>
      <td>2</td>
      <td>FALSE</td>
      <td>902</td>
      <td>906</td>
    </tr>
    <tr>
      <td>94555</td>
      <td>north</td>
      <td>1835</td>
      <td>3</td>
      <td>3</td>
      <td>3</td>
      <td>TRUE</td>
      <td>888</td>
      <td>892</td>
    </tr>
    <tr>
      <td>95141</td>
      <td>east</td>
      <td>2833</td>
      <td>6</td>
      <td>2.5</td>
      <td>2</td>
      <td>TRUE</td>
      <td>927</td>
      <td>932</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>south</td>
      <td>2742</td>
      <td>6</td>
      <td>2.5</td>
      <td>2</td>
      <td>FALSE</td>
      <td>872</td>
      <td>876</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>north</td>
      <td>2195</td>
      <td>5</td>
      <td>2.5</td>
      <td>2</td>
      <td>FALSE</td>
      <td>799</td>
      <td>803</td>
    </tr>
    <tr>
      <td>98755</td>
      <td>north</td>
      <td>3469</td>
      <td>7</td>
      <td>2.5</td>
      <td>2</td>
      <td>FALSE</td>
      <td>958</td>
      <td>963</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>west</td>
      <td>1685</td>
      <td>7</td>
      <td>1.5</td>
      <td>2</td>
      <td>TRUE</td>
      <td>757</td>
      <td>760</td>
    </tr>
    <tr>
      <td>95141</td>
      <td>west</td>
      <td>2238</td>
      <td>4</td>
      <td>3</td>
      <td>3</td>
      <td>FALSE</td>
      <td>894</td>
      <td>899</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>west</td>
      <td>1245</td>
      <td>4</td>
      <td>1</td>
      <td>1</td>
      <td>FALSE</td>
      <td>547</td>
      <td>549</td>
    </tr>
    <tr>
      <td>98755</td>
      <td>south</td>
      <td>3702</td>
      <td>7</td>
      <td>3</td>
      <td>1</td>
      <td>FALSE</td>
      <td>959</td>
      <td>964</td>
    </tr>
    <tr>
      <td>98755</td>
      <td>north</td>
      <td>1865</td>
      <td>7</td>
      <td>1</td>
      <td>2</td>
      <td>TRUE</td>
      <td>742</td>
      <td>745</td>
    </tr>
    <tr>
      <td>94555</td>
      <td>north</td>
      <td>3837</td>
      <td>3</td>
      <td>1</td>
      <td>1</td>
      <td>FALSE</td>
      <td>839</td>
      <td>842</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>west</td>
      <td>2139</td>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>TRUE</td>
      <td>820</td>
      <td>824</td>
    </tr>
    <tr>
      <td>95141</td>
      <td>north</td>
      <td>3824</td>
      <td>4</td>
      <td>3</td>
      <td>1</td>
      <td>FALSE</td>
      <td>954</td>
      <td>958</td>
    </tr>
    <tr>
      <td>98755</td>
      <td>east</td>
      <td>2858</td>
      <td>5</td>
      <td>1.5</td>
      <td>1</td>
      <td>FALSE</td>
      <td>759</td>
      <td>762</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>south</td>
      <td>1827</td>
      <td>7</td>
      <td>3</td>
      <td>1</td>
      <td>FALSE</td>
      <td>735</td>
      <td>738</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>south</td>
      <td>3557</td>
      <td>2</td>
      <td>2.5</td>
      <td>1</td>
      <td>FALSE</td>
      <td>888</td>
      <td>892</td>
    </tr>
    <tr>
      <td>91312</td>
      <td>south</td>
      <td>2553</td>
      <td>2</td>
      <td>2.5</td>
      <td>2</td>
      <td>TRUE</td>
      <td>884</td>
      <td>889</td>
    </tr>
    <tr>
      <td>96334</td>
      <td>west</td>
      <td>1682</td>
      <td>3</td>
      <td>1.5</td>
      <td>1</td>
      <td>FALSE</td>
      <td>625</td>
      <td>628</td>
    </tr>
  </tbody>
</table>

<p>The metadata file <a href="files/dml-language-reference/homes.csv.mtd"><code class="language-plaintext highlighter-rouge">homes.csv.mtd</code></a> looks as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "frame",
    "format": "csv",
    "header": true,
}
</code></pre></div></div>

<h4 id="transformencode">transformencode</h4>

<p>The <code>transformencode()</code> function takes a frame and outputs a matrix based on defined transformation specification.  In addition, the corresponding metadata is output as a <code>frame</code>.</p>

<p><em>Note: the metadata output is simply a frame so all frame operations (including read/write) can also be applied to the metadata.</em></p>

<p>This example replaces values in specific columns to create a recoded matrix with associated frame identifying the mapping between original and substituted values.  An example transformation specification file <a href="files/dml-language-reference/homes.tfspec_recode2.json"><code class="language-plaintext highlighter-rouge">homes.tfspec_recode2.json</code></a> is given below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
     "recode": [ "zipcode", "district", "view" ]
}
</code></pre></div></div>

<p>The following DML utilizes the <code class="language-plaintext highlighter-rouge">transformencode()</code> function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F1 = read("/user/ml/homes.csv", data_type="frame", format="csv");
jspec = read("/user/ml/homes.tfspec_recode2.json", data_type="scalar", value_type="string");
[X, M] = transformencode(target=F1, spec=jspec);
print(toString(X));
while(FALSE){}
print(toString(M));
</code></pre></div></div>

<p>The transformed matrix X and output M are as follows.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.000 1.000 1373.000 7.000 1.000 3.000 1.000 695.000 698.000
2.000 2.000 3261.000 6.000 2.000 2.000 1.000 902.000 906.000
3.000 3.000 1835.000 3.000 3.000 3.000 2.000 888.000 892.000
1.000 4.000 2833.000 6.000 2.500 2.000 2.000 927.000 932.000
4.000 2.000 2742.000 6.000 2.500 2.000 1.000 872.000 876.000
4.000 3.000 2195.000 5.000 2.500 2.000 1.000 799.000 803.000
5.000 3.000 3469.000 7.000 2.500 2.000 1.000 958.000 963.000
4.000 1.000 1685.000 7.000 1.500 2.000 2.000 757.000 760.000
1.000 1.000 2238.000 4.000 3.000 3.000 1.000 894.000 899.000
2.000 1.000 1245.000 4.000 1.000 1.000 1.000 547.000 549.000
5.000 2.000 3702.000 7.000 3.000 1.000 1.000 959.000 964.000
5.000 3.000 1865.000 7.000 1.000 2.000 2.000 742.000 745.000
3.000 3.000 3837.000 3.000 1.000 1.000 1.000 839.000 842.000
2.000 1.000 2139.000 3.000 1.000 3.000 2.000 820.000 824.000
1.000 3.000 3824.000 4.000 3.000 1.000 1.000 954.000 958.000
5.000 4.000 2858.000 5.000 1.500 1.000 1.000 759.000 762.000
2.000 2.000 1827.000 7.000 3.000 1.000 1.000 735.000 738.000
2.000 2.000 3557.000 2.000 2.500 1.000 1.000 888.000 892.000
2.000 2.000 2553.000 2.000 2.500 2.000 2.000 884.000 889.000
4.000 1.000 1682.000 3.000 1.500 1.000 1.000 625.000 628.000


# FRAME: nrow = 5, ncol = 9
# zipcode district sqft numbedrooms numbathrooms floors view saleprice askingprice
# STRING STRING STRING STRING STRING STRING STRING STRING STRING
96334·4 south·2 FALSE·1
95141·1 east·4 TRUE·2
98755·5 north·3
94555·3 west·1
91312·2
</code></pre></div></div>

<p><br />
As mentioned in <a href="#creating-frames">Creating Frames</a>, the header line in frame CSV files is sensitive to white space.  The tabs below show compatible transform specifications for the given CSV header.  Note the extra (possibly inadvertent) space before the <code> district</code> column in CSV2 impacts the transform specification.  More specifically,  transform spec1 does not match the header in CSV2.  To match, either remove the extra space before <code> district</code> in CSV2 or use spec2 which quotes the <code> district</code> token name to include the extra space.</p>

<div class="codetabs2">

<div data-lang="CSV1">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zipcode,district,sqft,numbedrooms,numbathrooms,floors,view,saleprice,askingprice
95141,west,1373,7,1,3,FALSE,695,698
91312,south,3261,6,2,2,FALSE,902,906
</code></pre></div>    </div>
  </div>

<div data-lang="CSV2">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zipcode, district,sqft,numbedrooms,numbathrooms,floors,view,saleprice,askingprice
95141,west,1373,7,1,3,FALSE,695,698
91312,south,3261,6,2,2,FALSE,902,906
</code></pre></div>    </div>
  </div>

<div data-lang="spec1">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
     ids:false, recode: [ zipcode, district, view ]
}
</code></pre></div>    </div>
  </div>

<div data-lang="spec2">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
     ids:false, recode: [ zipcode, " district", view ]
}
</code></pre></div>    </div>
  </div>

<div data-lang="CSV MTD">
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "data_type": "frame",
    "format": "csv",
    "header": true
}
</code></pre></div>    </div>
  </div>

</div>
<p><br /></p>

<h4 id="transformdecode">transformdecode</h4>

<p>The <code>transformdecode()</code> function can be used to transform a <code>matrix</code> back into a <code>frame</code>.  Only recoding, dummy coding and pass-through transformations are reversible and can be used with <code>transformdecode()</code>.  The transformations binning, missing value imputation, and omit are not reversible and cannot be used with <code>transformdecode()</code>.</p>

<p>The next example takes the outputs from the <a href="#transformencode">transformencode</a> example and reconstructs the original data using the same transformation specification.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F1 = read("/user/ml/homes.csv", data_type="frame", format="csv");
jspec = read("/user/ml/homes.tfspec_recode2.json", data_type="scalar", value_type="string");
[X, M] = transformencode(target=F1, spec=jspec);
F2 = transformdecode(target=X, spec=jspec, meta=M);
print(toString(F2));

# FRAME: nrow = 20, ncol = 9
# C1 C2 C3 C4 C5 C6 C7 C8 C9
# STRING STRING DOUBLE DOUBLE DOUBLE DOUBLE STRING DOUBLE DOUBLE
95141 west  1373.000 7.000 1.000 3.000 FALSE 695.000 698.000
91312 south 3261.000 6.000 2.000 2.000 FALSE 902.000 906.000
94555 north 1835.000 3.000 3.000 3.000 TRUE  888.000 892.000
95141 east  2833.000 6.000 2.500 2.000 TRUE  927.000 932.000
96334 south 2742.000 6.000 2.500 2.000 FALSE 872.000 876.000
96334 north 2195.000 5.000 2.500 2.000 FALSE 799.000 803.000
98755 north 3469.000 7.000 2.500 2.000 FALSE 958.000 963.000
96334 west  1685.000 7.000 1.500 2.000 TRUE  757.000 760.000
95141 west  2238.000 4.000 3.000 3.000 FALSE 894.000 899.000
91312 west  1245.000 4.000 1.000 1.000 FALSE 547.000 549.000
98755 south 3702.000 7.000 3.000 1.000 FALSE 959.000 964.000
98755 north 1865.000 7.000 1.000 2.000 TRUE  742.000 745.000
94555 north 3837.000 3.000 1.000 1.000 FALSE 839.000 842.000
91312 west  2139.000 3.000 1.000 3.000 TRUE  820.000 824.000
95141 north 3824.000 4.000 3.000 1.000 FALSE 954.000 958.000
98755 east  2858.000 5.000 1.500 1.000 FALSE 759.000 762.000
91312 south 1827.000 7.000 3.000 1.000 FALSE 735.000 738.000
91312 south 3557.000 2.000 2.500 1.000 FALSE 888.000 892.000
91312 south 2553.000 2.000 2.500 2.000 TRUE  884.000 889.000
96334 west  1682.000 3.000 1.500 1.000 FALSE 625.000 628.000
</code></pre></div></div>

<h4 id="transformapply">transformapply</h4>

<p>In contrast to <code>transformencode()</code>, which creates and applies frame metadata (transformencode := build+apply), <code>transformapply()</code> applies <em>existing</em> metadata (transformapply := apply).</p>

<p>The following example uses <code>transformapply()</code> with the input matrix and second output (i.e., existing frame metadata built with <code>transformencode()</code>) from the <a href="#transformencode">transformencode</a> example for the <a href="files/dml-language-reference/homes.tfspec_bin2.json"><code class="language-plaintext highlighter-rouge">homes.tfspec_bin2.json</code></a> transformation specification.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 "recode": [ zipcode, "district", "view" ], "bin": [
 { "name": "saleprice"  , "method": "equi-width", "numbins": 3 }
 ,{ "name": "sqft", "method": "equi-width", "numbins": 4 }]
}

F1 = read("/user/ml/homes.csv", data_type="frame", format="csv");
jspec = read("/user/ml/homes.tfspec_bin2.json", data_type="scalar", value_type="string");
[X, M] = transformencode(target=F1, spec=jspec);
X2 = transformapply(target=F1, spec=jspec, meta=M);
print(toString(X2));

1.000 1.000 1.000 7.000 1.000 3.000 1.000 1.000 698.000
2.000 2.000 1.000 6.000 2.000 2.000 1.000 1.000 906.000
3.000 3.000 1.000 3.000 3.000 3.000 2.000 1.000 892.000
1.000 4.000 1.000 6.000 2.500 2.000 2.000 1.000 932.000
4.000 2.000 1.000 6.000 2.500 2.000 1.000 1.000 876.000
4.000 3.000 1.000 5.000 2.500 2.000 1.000 1.000 803.000
5.000 3.000 1.000 7.000 2.500 2.000 1.000 1.000 963.000
4.000 1.000 1.000 7.000 1.500 2.000 2.000 1.000 760.000
1.000 1.000 1.000 4.000 3.000 3.000 1.000 1.000 899.000
2.000 1.000 1.000 4.000 1.000 1.000 1.000 1.000 549.000
5.000 2.000 1.000 7.000 3.000 1.000 1.000 1.000 964.000
5.000 3.000 1.000 7.000 1.000 2.000 2.000 1.000 745.000
3.000 3.000 1.000 3.000 1.000 1.000 1.000 1.000 842.000
2.000 1.000 1.000 3.000 1.000 3.000 2.000 1.000 824.000
1.000 3.000 1.000 4.000 3.000 1.000 1.000 1.000 958.000
5.000 4.000 1.000 5.000 1.500 1.000 1.000 1.000 762.000
2.000 2.000 1.000 7.000 3.000 1.000 1.000 1.000 738.000
2.000 2.000 1.000 2.000 2.500 1.000 1.000 1.000 892.000
2.000 2.000 1.000 2.000 2.500 2.000 2.000 1.000 889.000
4.000 1.000 1.000 3.000 1.500 1.000 1.000 1.000 628.000
</code></pre></div></div>

<h3 id="processing-frames">Processing Frames</h3>

<p><strong>Table F5</strong>: Frame processing built-in functions</p>

<table>
  <thead>
    <tr>
      <th>Function</th>
      <th>Description</th>
      <th>Parameters</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>map()</td>
      <td>It will execute the given lambda expression on a frame (cell, row or column wise).</td>
      <td>Input: (X &lt;frame&gt;, y &lt;String&gt;, [margin &lt;int&gt;]) <br />Output: &lt;frame&gt;. <br /> X is a frame and <br />y is a String containing the lambda expression to be executed on frame X. <br /> margin - how to apply the lambda expression (0 indicates each cell, 1 - rows, 2 - columns). Output matrix dimensions are always equal to the input.</td>
      <td><a href="#map">map</a></td>
    </tr>
    <tr>
      <td>tokenize()</td>
      <td>Transforms a frame to tokenized frame using specification. Tokenization is valid only for string columns.</td>
      <td>Input:<br /> target = &lt;frame&gt; <br /> spec = &lt;json specification&gt; <br /> Outputs: &lt;matrix&gt;, &lt;frame&gt;</td>
      <td><a href="#tokenize">tokenize</a></td>
    </tr>
  </tbody>
</table>

<h4 id="map">map</h4>

<p>The built-in function <code>map()</code> provides support for the lambda expressions.</p>

<p>Simple example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X = read("file1", data_type="frame", rows=2, cols=3, format="binary") &lt;br/&gt; y = "lambda expression" &lt;br/&gt; Z = map(X, y) &lt;br/&gt; # Dimensions of Z = Dimensions of X; &lt;br/&gt; example: &lt;br/&gt; &lt;code&gt; Z = map(X, "x -&gt; x.charAt(2)")     &lt;/code&gt;
</code></pre></div></div>

<p>Example with data let X =</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># FRAME: nrow = 10, ncol = 1
# C1 
# STRING 
  west
  south
  north
  east
  south
  north
  north
  west
  west
  east
</code></pre></div></div>

<p><code> Z = map(X, "x -&gt; x.toUpperCase()") <br /> 
print(toString(Z)) </code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># FRAME: nrow = 10, ncol = 1 
# C1 
# STRING 
  WEST
  SOUTH
  NORTH
  EAST
  SOUTH
  NORTH
  NORTH
  WEST
  WEST
  EAST
</code></pre></div></div>

<p>It is also possible to compute Jaccard similarity matrix of rows of a vector.
<code> dist = map(Xi, "(x, y) -&gt; UtilFunctions.jaccardSim(x, y)") <br /> 
print(toString(dist)) </code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># FRAME: nrow = 10, ncol = 10 
# DOUBLE 
# 0,000 0,286 0,125 0,600 0,286 0,125 0,125 1,000 1,000 0,600 
  0,286 0,000 0,429 0,286 1,000 0,429 0,429 0,286 0,286 0,286 
  0,125 0,429 0,000 0,125 0,429 1,000 1,000 0,125 0,125 0,125 
  0,600 0,286 0,125 0,000 0,286 0,125 0,125 0,600 0,600 1,000 
  0,286 1,000 0,429 0,286 0,000 0,429 0,429 0,286 0,286 0,286 
  0,125 0,429 1,000 0,125 0,429 0,000 1,000 0,125 0,125 0,125 
  0,125 0,429 1,000 0,125 0,429 1,000 0,000 0,125 0,125 0,125 
  1,000 0,286 0,125 0,600 0,286 0,125 0,125 0,000 1,000 0,600 
  1,000 0,286 0,125 0,600 0,286 0,125 0,125 1,000 0,000 0,600 
  0,600 0,286 0,125 1,000 0,286 0,125 0,125 0,600 0,600 0,000
#
</code></pre></div></div>

<h4 id="tokenize">tokenize</h4>

<p>Simple example</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X = read(“file1”, data_type=”frame”, rows=3, cols=2, format=”binary”);
spec = "{\"algo\": \"whitespace\",\"out\": \"count\",\"id_cols\": [1],\"tokenize_col\": 2}";
Y = tokenize(target=X, spec=jspec, max_tokens=1000);
write(Y, "file2");
</code></pre></div></div>

<p>Example spec</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "algo": "split",
  "out": "count",
  "id_cols": [1],
  "tokenize_col": 2
}
</code></pre></div></div>

<p>The frame is tokenized along the <code class="language-plaintext highlighter-rouge">tokenize_col</code> and replicates the <code class="language-plaintext highlighter-rouge">id_cols</code>.</p>

<p>The output frame can be converted into a matrix with the transform functions. For instance, using <code class="language-plaintext highlighter-rouge">transformencode</code> with <code class="language-plaintext highlighter-rouge">recode</code>, followed by <code class="language-plaintext highlighter-rouge">table</code>.
Alternatively, for certain algorithms by specifying <code class="language-plaintext highlighter-rouge">"format_wide": true</code> expands the tokens in the columns instead of creating new rows.</p>

<p><strong>Table F6</strong>: Tokenizer Algorithms for <code class="language-plaintext highlighter-rouge">algo</code> field</p>

<table>
  <thead>
    <tr>
      <th>Algorithm</th>
      <th>Algo Description</th>
      <th>Parameters</th>
      <th>Spec Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>whitespace</td>
      <td>Splits the tokens along whitespace characters.</td>
      <td>None</td>
      <td><code class="language-plaintext highlighter-rouge">"{\"algo\": \"whitespace\",\"out\": \"count\",\"out_params\": {\"sort_alpha\": true},\"id_cols\": \[2\],\"tokenize_col\": 3}"</code></td>
    </tr>
    <tr>
      <td>ngram</td>
      <td>Pretokenizes using <code class="language-plaintext highlighter-rouge">whitespace</code> then splits the tokens into ngrams</td>
      <td><code class="language-plaintext highlighter-rouge">min_gram</code> and <code class="language-plaintext highlighter-rouge">max_gram</code> specify the length of the ngrams.</td>
      <td><code class="language-plaintext highlighter-rouge">"{\"algo\": \"ngram\",\"algo_params\": {\"min_gram\": 2,\"max_gram\": 3},\"out\": \"position\",\"id_cols\": \[1,2\],\"tokenize_col\": 3}"</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Table F7</strong>: Output Representations of Tokens for <code class="language-plaintext highlighter-rouge">out</code> field</p>

<table>
  <thead>
    <tr>
      <th>Out Representation</th>
      <th>Format Description</th>
      <th>Parameters</th>
      <th>Format Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>count</td>
      <td>Outputs the <code class="language-plaintext highlighter-rouge">id_cols</code>, the <code class="language-plaintext highlighter-rouge">tokens</code>, and the number of token <code class="language-plaintext highlighter-rouge">occurences</code> per document.</td>
      <td><code class="language-plaintext highlighter-rouge">sort_alpha</code> specifies whether the tokens are sorted alphanumerically per document.</td>
      <td><code class="language-plaintext highlighter-rouge">id1,id2,token1,3</code></td>
    </tr>
    <tr>
      <td>position</td>
      <td>Outputs the <code class="language-plaintext highlighter-rouge">id_cols</code>, the <code class="language-plaintext highlighter-rouge">position</code> within the document, and the <code class="language-plaintext highlighter-rouge">token</code>.</td>
      <td>None</td>
      <td><code class="language-plaintext highlighter-rouge">id1,id2,1,token1</code></td>
    </tr>
    <tr>
      <td>hash</td>
      <td>Outputs the <code class="language-plaintext highlighter-rouge">id_cols</code>, the <code class="language-plaintext highlighter-rouge">index</code> of non-zero hashes, and the <code class="language-plaintext highlighter-rouge">hashes</code></td>
      <td><code class="language-plaintext highlighter-rouge">num_features</code> specifies the number of output features</td>
      <td><code class="language-plaintext highlighter-rouge">id1,id2,2,64</code></td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="modules">Modules</h2>

<p>A module is a collection of UDF declarations. For calling a module, source(&#8230;) and setwd(&#8230;) are used to read and use a source file.</p>

<h3 id="syntax-1">Syntax</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setwd(&lt;file-path&gt;);
source(&lt;DML-filename&gt;) as &lt;namespace-name&gt;;
</code></pre></div></div>

<p>It is important to note that:</p>

<ol>
  <li>setwd(&#8230;) and source(&#8230;) do not support $-parameters. </li>
  <li>Nested namespaces are not supported.</li>
  <li>Namespace are required for source(&#8230;).</li>
  <li>Only UDFs are imported, not the statements.</li>
  <li>Path for input/output files is not affected by setwd.</li>
  <li>setwd is applicable only for local filesystem not HDFS.</li>
  <li>Spaces are not allowed between namespace and function name during call. For example: ns1::foo(&#8230;) is correct way to call the function.</li>
  <li>Like R, the path of source() is relative to where the calling java program is running.</li>
</ol>

<h3 id="example-4">Example</h3>

<p>Assume the file a.dml contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#source("/home/ml/spark_test/b.dml") as ns1 # will work
#source("b.dml") as ns1 # will work
#source("./b.dml") as ns1 # will work
source("hdfs:/user/ml/nike/b.dml") as ns1
f1 = function() {
    print("From a.dml's function()");
}
setwd("dir1")
source("c.dml") as ns2
tmp = ns2::f();
tmp1 = ns1::f();
tmp = f1();
</code></pre></div></div>

<p>The file b.dml contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = function() {
    print("From b.dml's function()");
}
</code></pre></div></div>

<p>The file c.dml contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f = function() {
    print("From c.dml's function()");
}
</code></pre></div></div>

<p>The output after running a.dml is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>From c.dml's function()
From b.dml's function()
From a.dml's function()
</code></pre></div></div>

<h2 id="reserved-keywords">Reserved Keywords</h2>

<p>Reserved keywords cannot be used as variable names.</p>

<p>All reserved keywords are case-sensitive.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>as
boolean
Boolean
double
Double
else
externalFunction
for
function
FALSE
if
ifdef
implemented
in
int
integer
Int
Integer
parfor
return
setwd
source
string
String
TRUE
while
</code></pre></div></div>

    </div>
    <!--

-->


<!-- MathJax Section -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "AMS" } } });
</script>
<script>
    // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
    // We could use "//cdn.mathjax...", but that won't support "file://".
    (function(d, script) {
        script = d.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.onload = function() {
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [
                        ["$", "$"],
                        ["\\\\(", "\\\\)"]
                    ],
                    displayMath: [
                        ["$$", "$$"],
                        ["\\[", "\\]"]
                    ],
                    processEscapes: true,
                    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                }
            });
        };
        script.src = ('https:' == document.location.protocol ? 'https://' : 'http://') +
            'cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        d.getElementsByTagName('head')[0].appendChild(script);
    }(document));
</script>

</body>

</html>